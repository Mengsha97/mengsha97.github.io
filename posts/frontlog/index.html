<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>【学习记录】JavaScript - Simona's Blog</title><meta name=Description content><meta property="og:title" content="【学习记录】JavaScript"><meta property="og:description" content="将<script>放在 HTML 文件的底部附近的原因浏览器会按照代码在文件中的顺序加载 HTML，如果先加载的 JavaScript 期望修改其下方的 HTML，那么它可能由于 HTML 尚未被加载而失效。因此，将 JavaScript 代码放在 HTML 页面的底部附近通常是最好的策略。
JavaScript 的命名规则一个 JavaScript 标识符必须以字母、下划线（_）或者美元符号（$）开头；后续的字符也可以是数字（0-9）。因为 JavaScript 语言是区分大小写的，所以字母可以是从“A”到“Z”的大写字母和从“a”到“z”的小写字母。
数据类型JavaScript 是一种弱类型或者说动态语言。这意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。这也意味着可以使用同一个变量保存不同类型的数据：
7 种原始类型: Boolean Null Undefined Number BigInt String Symbol 和 Object 数学运算符 幂次 运算符 名称 作用 示例 ** 幂次 取底数的指数次方，即指数所指定的底数相乘。它在 EcmaScript 2016 中首次引入。 5 *_ 5 (返回 3125，相当于 5 _ 5 _ 5 _ 5 * 5 。) 数组的 join()函数数组 join（）函数的参数是可选的，如果没有包含参数来指定加入/分隔符，默认情况下会使用逗号。例如，
var myArray = [&#34;I&#34;, &#34;love&#34;, &#34;chocolate&#34;, &#34;frogs&#34;]; var madeAString = myArray."><meta property="og:type" content="article"><meta property="og:url" content="http://mengsha97.github.io/posts/frontlog/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-02-17T01:46:17+00:00"><meta property="article:modified_time" content="2020-02-17T01:46:17+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="【学习记录】JavaScript"><meta name=twitter:description content="将<script>放在 HTML 文件的底部附近的原因浏览器会按照代码在文件中的顺序加载 HTML，如果先加载的 JavaScript 期望修改其下方的 HTML，那么它可能由于 HTML 尚未被加载而失效。因此，将 JavaScript 代码放在 HTML 页面的底部附近通常是最好的策略。
JavaScript 的命名规则一个 JavaScript 标识符必须以字母、下划线（_）或者美元符号（$）开头；后续的字符也可以是数字（0-9）。因为 JavaScript 语言是区分大小写的，所以字母可以是从“A”到“Z”的大写字母和从“a”到“z”的小写字母。
数据类型JavaScript 是一种弱类型或者说动态语言。这意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。这也意味着可以使用同一个变量保存不同类型的数据：
7 种原始类型: Boolean Null Undefined Number BigInt String Symbol 和 Object 数学运算符 幂次 运算符 名称 作用 示例 ** 幂次 取底数的指数次方，即指数所指定的底数相乘。它在 EcmaScript 2016 中首次引入。 5 *_ 5 (返回 3125，相当于 5 _ 5 _ 5 _ 5 * 5 。) 数组的 join()函数数组 join（）函数的参数是可选的，如果没有包含参数来指定加入/分隔符，默认情况下会使用逗号。例如，
var myArray = [&#34;I&#34;, &#34;love&#34;, &#34;chocolate&#34;, &#34;frogs&#34;]; var madeAString = myArray."><meta name=application-name content="Simona's Blog"><meta name=apple-mobile-web-app-title content="Simona's Blog"><meta name=theme-color content="#f8f8f8"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=canonical href=http://mengsha97.github.io/posts/frontlog/><link rel=prev href=http://mengsha97.github.io/posts/blog-log/><link rel=next href=http://mengsha97.github.io/posts/imooc-promise/><link rel=stylesheet href=/css/main.css><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/color.css><link rel=stylesheet href=/css/style.min.css><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/fontawesome-free/all.min.css><noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/animate/animate.min.css><noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"【学习记录】JavaScript","inLanguage":"zh-cn","mainEntityOfPage":{"@type":"WebPage","@id":"http://mengsha97.github.io/posts/frontlog/"},"genre":"posts","keywords":"JavaScript","wordcount":313,"url":"http://mengsha97.github.io/posts/frontlog/","datePublished":"2020-02-17T01:46:17+00:00","dateModified":"2020-02-17T01:46:17+00:00","publisher":{"@type":"Organization","name":"作者"},"authors":[{"@type":"Person","name":"Simona"}],"description":""}</script></head><body header-desktop header-mobile><script type=text/javascript>function setTheme(e){document.body.setAttribute("theme",e),document.documentElement.style.setProperty("color-scheme",e==="light"?"light":"dark"),window.theme=e,window.isDark=window.theme!=="light"}function saveTheme(e){window.localStorage&&localStorage.setItem("theme",e)}function getMeta(e){const t=document.getElementsByTagName("meta");for(let n=0;n<t.length;n++)if(t[n].getAttribute("name")===e)return t[n];return""}if(window.localStorage&&localStorage.getItem("theme")){let e=localStorage.getItem("theme");e==="light"||e==="dark"||e==="black"?setTheme(e):setTheme(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light")}else""==="light"||""==="dark"||""==="black"?(setTheme(""),saveTheme("")):(saveTheme("auto"),setTheme(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light"));let metaColors={light:"#f8f8f8",dark:"#252627",black:"#000000"};getMeta("theme-color").content=metaColors[document.body.getAttribute("theme")],window.switchThemeEventSet=new Set</script><div id=back-to-top></div><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="Simona's Blog">Simona's Blog</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>Posts
</a><a class=menu-item href=/tags/>Tags
</a><a class=menu-item href=/categories/>Categories
</a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Simona's Blog">Simona's Blog</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>Posts</a><a class=menu-item href=/tags/ title>Tags</a><a class=menu-item href=/categories/ title>Categories</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><article class="page single"><h1 class="single-title animate__animated animate__flipInX">【学习记录】JavaScript</h1><div class=post-meta><div class=post-meta-line><span class=post-author><span class=author><span class="author fas fa-user-circle fa-fw"></span><span class=screen-reader-text> </span><a href=http://mengsha97.github.io/authors/simona>Simona</a></span>
</span>&nbsp;<span class=post-category>收录于 </span>&nbsp;<span class=post-category>类别 <a href=/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/><i class="far fa-folder fa-fw"></i>学习记录</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2020-02-17>2020-02-17</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime=2020-02-17>2020-02-17</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 313 字&nbsp;<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 2 分钟&nbsp;</div></div><div class=content id=content><h2 id=将script放在-html-文件的底部附近的原因 class=headerLink><a href=#%e5%b0%86script%e6%94%be%e5%9c%a8-html-%e6%96%87%e4%bb%b6%e7%9a%84%e5%ba%95%e9%83%a8%e9%99%84%e8%bf%91%e7%9a%84%e5%8e%9f%e5%9b%a0 class=header-mark></a>将<code>&lt;script></code>放在 HTML 文件的底部附近的原因</h2><p>浏览器会按照代码在文件中的顺序加载 HTML，如果先加载的 JavaScript 期望修改其下方的 HTML，那么它可能由于 HTML 尚未被加载而失效。因此，将 JavaScript 代码放在 HTML 页面的底部附近通常是最好的策略。</p><h2 id=javascript-的命名规则 class=headerLink><a href=#javascript-%e7%9a%84%e5%91%bd%e5%90%8d%e8%a7%84%e5%88%99 class=header-mark></a>JavaScript 的命名规则</h2><p>一个 JavaScript 标识符必须以字母、下划线（_）或者美元符号（$）开头；后续的字符也可以是数字（0-9）。因为 JavaScript 语言是区分大小写的，所以字母可以是从“A”到“Z”的大写字母和从“a”到“z”的小写字母。</p><h2 id=数据类型 class=headerLink><a href=#%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b class=header-mark></a>数据类型</h2><p>JavaScript 是一种弱类型或者说动态语言。这意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。这也意味着可以使用同一个变量保存不同类型的数据：</p><ul><li>7 种原始类型:<ul><li>Boolean</li><li>Null</li><li>Undefined</li><li>Number</li><li>BigInt</li><li>String</li><li>Symbol</li></ul></li><li>和 Object</li></ul><h2 id=数学运算符-幂次 class=headerLink><a href=#%e6%95%b0%e5%ad%a6%e8%bf%90%e7%ae%97%e7%ac%a6-%e5%b9%82%e6%ac%a1 class=header-mark></a>数学运算符 幂次</h2><table><thead><tr><th>运算符</th><th style=text-align:center>名称</th><th style=text-align:right>作用</th><th style=text-align:right>示例</th></tr></thead><tbody><tr><td>**</td><td style=text-align:center>幂次</td><td style=text-align:right>取底数的指数次方，即指数所指定的底数相乘。它在 EcmaScript 2016 中首次引入。</td><td style=text-align:right>5 *_ 5 (返回 3125，相当于 5 _ 5 _ 5 _ 5 * 5 。)</td></tr></tbody></table><h2 id=数组的-join函数 class=headerLink><a href=#%e6%95%b0%e7%bb%84%e7%9a%84-join%e5%87%bd%e6%95%b0 class=header-mark></a>数组的 join()函数</h2><p>数组 join（）函数的参数是可选的，如果没有包含参数来指定加入/分隔符，默认情况下会使用逗号。例如，</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>var</span> <span class=nx>myArray</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;I&#34;</span><span class=p>,</span> <span class=s2>&#34;love&#34;</span><span class=p>,</span> <span class=s2>&#34;chocolate&#34;</span><span class=p>,</span> <span class=s2>&#34;frogs&#34;</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>madeAString</span> <span class=o>=</span> <span class=nx>myArray</span><span class=p>.</span><span class=nx>join</span><span class=p>(</span><span class=s2>&#34; &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// returns &#39;I love chocolate frogs&#39;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>madeAString</span> <span class=o>=</span> <span class=nx>myArray</span><span class=p>.</span><span class=nx>join</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=c1>// returns &#39;I,love,chocolate,frogs&#39;
</span></span></span></code></pre></div><h2 id=函数调用运算符 class=headerLink><a href=#%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8%e8%bf%90%e7%ae%97%e7%ac%a6 class=header-mark></a>函数调用运算符</h2><p>在函数名后面的括号叫做“函数调用运算符”，只有在想直接调用函数的地方才写。例如，</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>btn</span><span class=p>.</span><span class=nx>onclick</span> <span class=o>=</span> <span class=nx>displayMessage</span><span class=p>;</span> <span class=c1>//没有括号，函数不会调用，只会在点击之后调用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>btn</span><span class=p>.</span><span class=nx>onclick</span> <span class=o>=</span> <span class=nx>displayMessage</span><span class=p>();</span> <span class=c1>//有括号，代码运行到这行会直接调用函数,并且之后点击也不会调用该函数
</span></span></span></code></pre></div><h2 id=对象的括号表示法 class=headerLink><a href=#%e5%af%b9%e8%b1%a1%e7%9a%84%e6%8b%ac%e5%8f%b7%e8%a1%a8%e7%a4%ba%e6%b3%95 class=header-mark></a>对象的括号表示法</h2><p>点表示法只能接受字面量的成员的名字，不接受变量作为名字，但是括号表示法可以接受变量作为名字，如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>var</span> <span class=nx>myDataName</span> <span class=o>=</span> <span class=s2>&#34;height&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>myDataValue</span> <span class=o>=</span> <span class=s2>&#34;1.75m&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>person</span><span class=p>[</span><span class=nx>myDataName</span><span class=p>]</span> <span class=o>=</span> <span class=nx>myDataValue</span><span class=p>;</span> <span class=c1>//person是一个对象
</span></span></span></code></pre></div><p>在控制台输入</p><pre tabindex=0><code>person.height
</code></pre><p>会输出</p><pre tabindex=0><code>1.75m
</code></pre><p>即把“height”当作了对象的成员名，“1.75m”当作了“height”的属性值。</p><h2 id=javascript-中的继承有关问题 class=headerLink><a href=#javascript-%e4%b8%ad%e7%9a%84%e7%bb%a7%e6%89%bf%e6%9c%89%e5%85%b3%e9%97%ae%e9%a2%98 class=header-mark></a>JavaScript 中的继承有关问题</h2><p>每一个函数对象（Function）都有一个 prototype 属性，并且只有函数对象有 prototype 属性，因为 prototype 本身就是定义在 Function 对象下的属性。当我们输入类似 var person1=new Person(&mldr;)来构造对象时，JavaScript 实际上参考的是 Person.prototype 指向的对象来生成 person1。另一方面，Person()函数是 Person.prototype 的构造函数，也就是说 Person===Person.prototype.constructor（不信的话可以试试）。</p><p>在定义新的构造函数 Teacher 时，我们通过 function.call 来调用父类的构造函数，但是这样无法自动指定 Teacher.prototype 的值，这样 Teacher.prototype 就只能包含在构造函数里构造的属性，而没有方法。因此我们利用 Object.create()方法将 Person.prototype 作为 Teacher.prototype 的原型对象，并改变其构造器指向，使之与 Teacher 关联。</p><p>任何您想要被继承的方法都应该定义在构造函数的 prototype 对象里，并且永远使用父类的 prototype 来创造子类的 prototype，这样才不会打乱类继承结构。</p><h2 id=对象成员总结 class=headerLink><a href=#%e5%af%b9%e8%b1%a1%e6%88%90%e5%91%98%e6%80%bb%e7%bb%93 class=header-mark></a>对象成员总结</h2><ol><li>那些定义在构造器函数中的、用于给予对象实例的。这些都很容易发现 - 在您自己的代码中，它们是构造函数中使用 this.x = x 类型的行；在内置的浏览器代码中，它们是可用于对象实例的成员（通常通过使用 new 关键字调用构造函数来创建，例如 var myInstance = new myConstructor()）。</li><li>那些直接在构造函数上定义、仅在构造函数上可用的。这些通常仅在内置的浏览器对象中可用，并通过被直接链接到构造函数而不是实例来识别。 例如 Object.keys()。</li><li>那些在构造函数原型上定义、由所有实例和对象类继承的。这些包括在构造函数的原型属性上定义的任何成员，如 myConstructor.prototype.x()。</li></ol><h2 id=json-的两个方法 class=headerLink><a href=#json-%e7%9a%84%e4%b8%a4%e4%b8%aa%e6%96%b9%e6%b3%95 class=header-mark></a>JSON 的两个方法</h2><ul><li>parse(): 以文本字符串形式接受 JSON 对象作为参数，并返回相应的对象。</li><li>stringify(): 接收一个对象作为参数，返回一个对应的 JSON 字符串。</li></ul><h2 id=异步编程 class=headerLink><a href=#%e5%bc%82%e6%ad%a5%e7%bc%96%e7%a8%8b class=header-mark></a>异步编程</h2><ul><li>老派 callbacks</li><li>新派 promise</li></ul><h2 id=递归-settimeout和-setinterval的差异 class=headerLink><a href=#%e9%80%92%e5%bd%92-settimeout%e5%92%8c-setinterval%e7%9a%84%e5%b7%ae%e5%bc%82 class=header-mark></a>递归 setTimeout()和 setInterval()的差异</h2><pre><code>- 递归 setTimeout() 保证执行之间的延迟相同，例如延迟为100ms。代码将运行，然后在它再次运行之前等待100ms，因此无论代码运行多长时间，间隔都是相同的。
- 使用 setInterval() 的示例有些不同。我们选择的间隔包括执行我们想要运行的代码所花费的时间。假设代码需要40毫秒才能运行 - 然后间隔最终只有60毫秒。
- 当递归使用 setTimeout() 时，每次迭代都可以在运行下一次迭代之前计算不同的延迟。 换句话说，第二个参数的值可以指定在再次运行代码之前等待的不同时间（以毫秒为单位）。
因此，当你的代码有可能比你分配的时间间隔，花费更长时间运行时，最好使用递归的 setTimeout() - 这将使执行之间的时间间隔保持不变，无论代码执行多长时间，你不会得到错误。
</code></pre><p>&mdash;&ndash;>摘自 MDN
<a href=https://developer.mozilla.org/zh-CN/docs/learn/JavaScript/%E5%BC%82%E6%AD%A5/%E8%B6%85%E6%97%B6%E5%92%8C%E9%97%B4%E9%9A%94 target=_blank rel="noopener noreferrer">https://developer.mozilla.org/zh-CN/docs/learn/JavaScript/%E5%BC%82%E6%AD%A5/%E8%B6%85%E6%97%B6%E5%92%8C%E9%97%B4%E9%9A%94</a>
下同</p><h2 id=requestanimationframe-与-setinterval-和-settimeout的差异 class=headerLink><a href=#requestanimationframe-%e4%b8%8e-setinterval-%e5%92%8c-settimeout%e7%9a%84%e5%b7%ae%e5%bc%82 class=header-mark></a>requestAnimationFrame() 与 setInterval() 和 setTimeout()的差异</h2><p>这是 requestAnimationFrame()</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>draw</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Drawing code goes here
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>requestAnimationFrame</span><span class=p>(</span><span class=nx>draw</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>draw</span><span class=p>();</span>
</span></span></code></pre></div><p>这是 setInterval()</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>draw</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Drawing code goes here
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>setInterval</span><span class=p>(</span><span class=nx>draw</span><span class=p>,</span> <span class=mi>17</span><span class=p>);</span>
</span></span></code></pre></div><ul><li>没有为 requestAnimationFrame();指定时间间隔；它只是在当前条件下尽可</li><li>另一方面 setInterval()需要指定间隔。我们通过公式 1000 毫秒/60Hz 得出 17 的最终值，然后将其四舍五入。四舍五入是一个好主意，浏览器可能会尝试运行动画的速度超过 60fps，它不会对动画的平滑度有任何影响。</li><li>60Hz 是标准刷新率。</li></ul><h2 id=offsetparentparentnodeparentelement-区别 class=headerLink><a href=#offsetparentparentnodeparentelement-%e5%8c%ba%e5%88%ab class=header-mark></a>offsetParent，parentNode,parentElement 区别</h2><ul><li>offsetParent 指与位置有关的上级元素</li><li>parentNode 指与位置无关的上级元素</li><li>parentElement 和 parentNode 一样，但是 parentNode 是 W3C 标准的,parentElement 只在 IE 中可用。</li></ul><h2 id=获取输入框-input-的值 class=headerLink><a href=#%e8%8e%b7%e5%8f%96%e8%be%93%e5%85%a5%e6%a1%86-input-%e7%9a%84%e5%80%bc class=header-mark></a>获取输入框 input 的值</h2><p>用.value 而不是.textContent</p><h2 id=从网络获取资源 class=headerLink><a href=#%e4%bb%8e%e7%bd%91%e7%bb%9c%e8%8e%b7%e5%8f%96%e8%b5%84%e6%ba%90 class=header-mark></a>从网络获取资源</h2><p>从网络获取资源是一个 asynchronous &ldquo;异步&rdquo; 操作, 这意味着您必须等待该操作完成（例如，资源从网络返回），然后才能对该响应执行任何操作，否则会出错,将被抛出错误。</p><h2 id=canvas class=headerLink><a href=#canvas class=header-mark></a>canvas</h2><ul><li>不明确指明宽高时，画布默认尺寸为 300*150 像素</li></ul><h2 id=ctxdrawimage class=headerLink><a href=#ctxdrawimage class=header-mark></a>ctx.drawImage()</h2><p>ctx.drawImage(image, 20, 20, 185, 175, 50, 50, 185, 175);</p><ul><li>第一个参数为图片引用。</li><li>参数 2、3 指定切片左上顶点在原图的位置坐标，参考原点为原图片本身左上角的坐标。原图片在该坐标左、上的部分均不会绘制出来。</li><li>参数 4、5 表示裁切部分的长、宽。</li><li>参数 6、7 表示裁切部分左上顶点在画布中的位置坐标，参考原点为画布左上顶点。</li><li>参数 8、9 表示裁切部分在画布中绘制的长、宽。本例中绘制时与裁切时面积相同，你也可以定制绘制的尺寸。</li></ul><h2 id=网络标准-rfc7230 class=headerLink><a href=#%e7%bd%91%e7%bb%9c%e6%a0%87%e5%87%86-rfc7230 class=header-mark></a>网络标准 RFC7230</h2><p>HTTP 消息的格式是在“网络标准”（RFC7230）中定义的。</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2020-02-17</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/javascript/>JavaScript</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/blog-log/ class=prev rel=prev title=关于博客><i class="fas fa-angle-left fa-fw"></i>关于博客</a>
<a href=/posts/imooc-promise/ class=next rel=next title="【慕课网】Promise 入门教程">【慕课网】Promise 入门教程<i class="fas fa-angle-right fa-fw"></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreferrer" title="Hugo 0.119.0">Hugo</a> 强力驱动&nbsp;|&nbsp;主题 - <a href=https://github.com/HEIGE-PCloud/DoIt target=_blank rel="noopener noreferrer" title="DoIt 0.4.0"><i class="far fa-edit fa-fw"></i> DoIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2024</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank rel="noopener noreferrer"></a></span></div><div class=footer-line></div><div class=footer-line></div></div></footer></div><div id=fixed-buttons><a href=#back-to-top id=back-to-top-button class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><div class=assets><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{}}</script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/js/theme.min.js defer></script></div></body></html>