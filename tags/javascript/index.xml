<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>JavaScript - 标签 - Simona's Blog</title><link>http://mengsha97.github.io/tags/javascript/</link><description>JavaScript - 标签 - Simona's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 27 Aug 2020 00:31:41 +0000</lastBuildDate><atom:link href="http://mengsha97.github.io/tags/javascript/" rel="self" type="application/rss+xml"/><item><title>【错误记录】苹果手机关于Date的某些操作兼容性问题</title><link>http://mengsha97.github.io/posts/js-error/</link><pubDate>Thu, 27 Aug 2020 00:31:41 +0000</pubDate><author><name>Simona</name><uri>https://github.com/Mengsha97</uri><email>laimengsha@qq.com</email></author><guid>http://mengsha97.github.io/posts/js-error/</guid><description><![CDATA[这是将 yyyy-mm-dd 转换成 yyyy/mm/dd 并通过 getTime()获得时间戳的例子，上面这段用正则转换是可以的，但是下面那个就不行，要好好学习下正则表达式了
（苹果手机可以显示）
let strTime = y + &#34;-&#34; + m + &#34;-&#34; + d; this.endTime = new Date(Date.parse(strTime.replace(/-/g, &#34;/&#34;))).getTime() - new Date().getTime(); （苹果手机不能显示）
let strTime = y + &#34;-&#34; + m + &#34;-&#34; + d; this.endTime = new Date(y + &#34;/&#34; + m + &#34;/&#34; + d).getTime() - new Date().getTime(); ]]></description></item><item><title>【学习记录】JavaScript中数组的sort函数</title><link>http://mengsha97.github.io/posts/js-sort/</link><pubDate>Tue, 14 Apr 2020 15:22:45 +0000</pubDate><author><name>Simona</name><uri>https://github.com/Mengsha97</uri><email>laimengsha@qq.com</email></author><guid>http://mengsha97.github.io/posts/js-sort/</guid><description>JavaScript 中的数组的 sort 函数使用示例 假如数组一开始是这样的
items: [23, 23, 11, 2, 41, 67, 23, 23231]; 使用完 sort 后
sortitems:function(){ return this.items.sort() } 结果
显然可以看出它的排序结果是一个一个位的数字来排的，从第一位（左边第一位）开始排，为了让它能够实现我们想要的效果，可以添加一个这样的函数：
function sortNumber(a, b) { return a - b; } 然后在使用 sort 时，把函数名放在 sort 函数的调用里，即
sortitems:function(){ return this.items.sort(sortNumber) } 就可以得到想要的结果了</description></item><item><title>【实战记录】MDN-Express Web Framework (Node.js/JavaScript)</title><link>http://mengsha97.github.io/posts/mdn-local-library/</link><pubDate>Mon, 23 Mar 2020 23:23:30 +0000</pubDate><author><name>Simona</name><uri>https://github.com/Mengsha97</uri><email>laimengsha@qq.com</email></author><guid>http://mengsha97.github.io/posts/mdn-local-library/</guid><description>实战网址：https://developer.mozilla.org/zh-CN/docs/Learn/Server-side/Express_Nodejs 源码：https://github.com/mdn/express-locallibrary-tutorial 搭建开发环境 安装 Node 下载安装包 访问 https://nodejs.org/zh-cn/ 点击“推荐多数用户使用”（LTS），下载。 安装（Node.js 与 npm 同时安装） 测试 Node.js 与 npm 是否安装成功 在命令行种输入：
$ node -v 与：
$ npm -v 看是否返回结果
安装 Express 应用生成器Express 应用生成器工具可以生成一个 Express 应用的“框架”，用 npm 全局安装（-g 参数可以将该工具全局安装，这样就可以在任意应用中使用了）
$ npm install express-generator -g 示例创建一个名为“helloword”的 Express 应用
$ express helloword 安装应用的所有依赖
$ cd helloworld $ npm install 运行这个应用（Windows 环境）：
&amp;gt; SET DEBUG=helloworld:* &amp;amp; npm start (Linux/macOS 环境)
$ DEBUG=helloworld:* npm start 这样设置之后，只要执行下面的命令，应用即启动，默认是 3000 端口</description></item><item><title>【慕课网】DOM事件探秘</title><link>http://mengsha97.github.io/posts/imooc-dom/</link><pubDate>Thu, 12 Mar 2020 16:34:54 +0000</pubDate><author><name>Simona</name><uri>https://github.com/Mengsha97</uri><email>laimengsha@qq.com</email></author><guid>http://mengsha97.github.io/posts/imooc-dom/</guid><description><![CDATA[讲师：Amy 课程：https://www.imooc.com/learn/138 第一章 事件流 1-1 [DOM] 事件冒泡事件流：描述的是从页面中接受事件的顺序 IE-事件冒泡流：即事件最开始由最具体的元素（文档中嵌套层次最深的那个节点）接受，然后逐级向上传播至最不具体的节点（文档）。
1-2 [DOM] 事件捕获Netscape-事件捕获流：不太具体的节点应该更早接收到事件，而最具体的节点最后接收到事件。
第二章 事件处理程序 2-1 HTML 事件处理程序例如：
&lt;input type=&#34;button&#34; value=&#34;按钮&#34; id=&#34;btn&#34; onclick=&#34;showMes()&#34; /&gt; 缺点：HTML 和 JS 代码紧密的耦合在一起;更新函数名时，JS 代码和 HTML 都要进行修改
2-2 DOM0 级事件处理程序较传统的方式：把一个函数赋值给一个事件的处理程序属性，用的比较多的方法，简单、跨浏览器的优势 例如：
var btn = document.getElementById(&#39;btn&#39;); btn.onclick = function(){ alert(&#39;这是通过DOM0级添加的事件&#39;); } btn.onclick = null;//删除事件 没有 HTML 事件处理程序的缺点
2-3 DOM2 级事件处理程序没有 DOM1 级 DOM2 级定义了两个方法： 用于处理指定和删除事件处理程序的操作 addEventListener()和 removeEventListener()。 所有 DOM 节点包含这两个方法 接收三个参数：要处理的事件名、作为事件处理程序的函数和布尔值 例如：
var btn = document.getElementById(&#39;btn&#39;); btn.addEventListener(&#39;click&#39;,showMes,false);//false可以兼容浏览器，冒泡阶段 btn.addEventListener(&#39;click&#39;,function(){ alert(this.value); },false);//按钮被点击后，先执行上面的事件，再进行这个事件 btn.]]></description></item><item><title>【错误记录】Failed to fetch</title><link>http://mengsha97.github.io/posts/myerror/</link><pubDate>Tue, 10 Mar 2020 20:27:50 +0000</pubDate><author><name>Simona</name><uri>https://github.com/Mengsha97</uri><email>laimengsha@qq.com</email></author><guid>http://mengsha97.github.io/posts/myerror/</guid><description><![CDATA[在学习过程中遇到的一个例子，无法运行，例子的代码如下
&lt;!DOCTYPE html&gt; &lt;html lang=&#34;en-US&#34;&gt; &lt;head&gt; &lt;meta charset=&#34;utf-8&#34;&gt; &lt;title&gt;My test page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;This is my page&lt;/p&gt; &lt;script&gt; /*let promise = fetch(&#39;coffee.jpg&#39;); let promise2 = promise.then(response=&gt;response.blob()); let promise3 = promise2.then(myBlob=&gt;{ let objectURL = URL.createObjectURL(myBlob); let image = document.createElement(&#39;img&#39;); image.src = objectURL; document.body.appendChild(image); });*/ fetch(&#39;coffee.jpg&#39;) .then(response =&gt; response.blob()) .then(myBlob =&gt; { let objectURL = URL.createObjectURL(myBlob); let image = document.createElement(&#39;img&#39;); image.src = objectURL; document.body.appendChild(image); }) .catch(e =&gt; { console.log(e.message); }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 遇到的问题如下]]></description></item><item><title>【慕课网】Promise 入门教程</title><link>http://mengsha97.github.io/posts/imooc-promise/</link><pubDate>Mon, 02 Mar 2020 14:27:33 +0000</pubDate><author><name>Simona</name><uri>https://github.com/Mengsha97</uri><email>laimengsha@qq.com</email></author><guid>http://mengsha97.github.io/posts/imooc-promise/</guid><description>讲师：翟路佳 课程：https://www.imooc.com/learn/949 代码：https://github.com/merrier/imooc-promise-sample 第一章 异步的问题 1-1 课程介绍 了解 Promise 诞生的历史背景 学会使用 Promise 解决异步回调带来的问题 掌握 Promise 的进阶用法 1-2 Promise 释义按照用途来解释
主要用于异步计算 可以将异步操作队列化，按照期望的顺序执行，返回复合预期的结果。 可以在对象之间传递和操作 Promise，帮助我们处理队列。 1-3 异步产生的原因 JavaScript 包含大量异步操作 有了 Node.js 之后，对异步的依赖进一步加剧了（无阻塞高并发，是 Node.js 的招牌；异步操作是其保障；大量操作依赖回调函数） 异步操作的常见语法 事件侦听与相应 回调 1-4 异步回调的问题 不好维护 异步回调函数会在一个新的栈运行，所以无法获取之前的栈的信息；之前的栈也无法捕获这个栈抛出的错误信息。所以没法正常使用 try catch 总结如下
嵌套层次很深，难以维护 无法正常使用 return 和 throw 无法正常检索堆栈信息 多个回调之间难以建立联系 第二章 Promise 入门 2-1 Promise 简介使用之前，初始化 Promise 实例
new Promise( /* 执行器executor */ function (resolve, reject) { //一段耗时很长的异步操作 resolve(); //数据处理完成 reject(); //数据处理出错 } ).</description></item><item><title>【学习记录】JavaScript</title><link>http://mengsha97.github.io/posts/frontlog/</link><pubDate>Mon, 17 Feb 2020 01:46:17 +0000</pubDate><author><name>Simona</name><uri>https://github.com/Mengsha97</uri><email>laimengsha@qq.com</email></author><guid>http://mengsha97.github.io/posts/frontlog/</guid><description><![CDATA[将&lt;script&gt;放在 HTML 文件的底部附近的原因浏览器会按照代码在文件中的顺序加载 HTML，如果先加载的 JavaScript 期望修改其下方的 HTML，那么它可能由于 HTML 尚未被加载而失效。因此，将 JavaScript 代码放在 HTML 页面的底部附近通常是最好的策略。
JavaScript 的命名规则一个 JavaScript 标识符必须以字母、下划线（_）或者美元符号（$）开头；后续的字符也可以是数字（0-9）。因为 JavaScript 语言是区分大小写的，所以字母可以是从“A”到“Z”的大写字母和从“a”到“z”的小写字母。
数据类型JavaScript 是一种弱类型或者说动态语言。这意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。这也意味着可以使用同一个变量保存不同类型的数据：
7 种原始类型: Boolean Null Undefined Number BigInt String Symbol 和 Object 数学运算符 幂次 运算符 名称 作用 示例 ** 幂次 取底数的指数次方，即指数所指定的底数相乘。它在 EcmaScript 2016 中首次引入。 5 *_ 5 (返回 3125，相当于 5 _ 5 _ 5 _ 5 * 5 。) 数组的 join()函数数组 join（）函数的参数是可选的，如果没有包含参数来指定加入/分隔符，默认情况下会使用逗号。例如，
var myArray = [&#34;I&#34;, &#34;love&#34;, &#34;chocolate&#34;, &#34;frogs&#34;]; var madeAString = myArray.]]></description></item></channel></rss>