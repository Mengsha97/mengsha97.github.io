<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>前端 - 标签 - Simona's Blog</title><link>http://mengsha97.github.io/tags/%E5%89%8D%E7%AB%AF/</link><description>前端 - 标签 - Simona's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 30 Mar 2020 00:49:20 +0000</lastBuildDate><atom:link href="http://mengsha97.github.io/tags/%E5%89%8D%E7%AB%AF/" rel="self" type="application/rss+xml"/><item><title>【学习记录】一些跨浏览器的方法</title><link>http://mengsha97.github.io/posts/cross-browser/</link><pubDate>Mon, 30 Mar 2020 00:49:20 +0000</pubDate><author><name>Simona</name><uri>https://github.com/Mengsha97</uri><email>laimengsha@qq.com</email></author><guid>http://mengsha97.github.io/posts/cross-browser/</guid><description><![CDATA[ SVG 跨浏览器支持 方法一在 img 元素内使用“src”属性引用 PNG 或 JPG 等低版本浏览器支持的类型，并且用“srcset”属性引用 SVG 类型，这种情况，支持的浏览器将加载 SVG，较旧的浏览器将加载 PNG 等。例如，
&lt;img src=&#34;equilateral.png&#34; alt=&#34;triangle with equal sides&#34; srcset=&#34;equilateral.svg&#34; /&gt; 方法二将 SVG 作为 CSS 背景图像，如下,旧浏览器会坚持 PNG 等，支持 SVG 的浏览器将加载 SVG
background: url(&#34;fallback.png&#34;) no-repeat center; background-image: url(&#34;image.svg&#34;); background-size: contain; ]]></description></item><item><title>【慕课网】DOM事件探秘</title><link>http://mengsha97.github.io/posts/imooc-dom/</link><pubDate>Thu, 12 Mar 2020 16:34:54 +0000</pubDate><author><name>Simona</name><uri>https://github.com/Mengsha97</uri><email>laimengsha@qq.com</email></author><guid>http://mengsha97.github.io/posts/imooc-dom/</guid><description><![CDATA[讲师：Amy 课程：https://www.imooc.com/learn/138 第一章 事件流 1-1 [DOM] 事件冒泡事件流：描述的是从页面中接受事件的顺序 IE-事件冒泡流：即事件最开始由最具体的元素（文档中嵌套层次最深的那个节点）接受，然后逐级向上传播至最不具体的节点（文档）。
1-2 [DOM] 事件捕获Netscape-事件捕获流：不太具体的节点应该更早接收到事件，而最具体的节点最后接收到事件。
第二章 事件处理程序 2-1 HTML 事件处理程序例如：
&lt;input type=&#34;button&#34; value=&#34;按钮&#34; id=&#34;btn&#34; onclick=&#34;showMes()&#34; /&gt; 缺点：HTML 和 JS 代码紧密的耦合在一起;更新函数名时，JS 代码和 HTML 都要进行修改
2-2 DOM0 级事件处理程序较传统的方式：把一个函数赋值给一个事件的处理程序属性，用的比较多的方法，简单、跨浏览器的优势 例如：
var btn = document.getElementById(&#39;btn&#39;); btn.onclick = function(){ alert(&#39;这是通过DOM0级添加的事件&#39;); } btn.onclick = null;//删除事件 没有 HTML 事件处理程序的缺点
2-3 DOM2 级事件处理程序没有 DOM1 级 DOM2 级定义了两个方法： 用于处理指定和删除事件处理程序的操作 addEventListener()和 removeEventListener()。 所有 DOM 节点包含这两个方法 接收三个参数：要处理的事件名、作为事件处理程序的函数和布尔值 例如：
var btn = document.getElementById(&#39;btn&#39;); btn.addEventListener(&#39;click&#39;,showMes,false);//false可以兼容浏览器，冒泡阶段 btn.addEventListener(&#39;click&#39;,function(){ alert(this.value); },false);//按钮被点击后，先执行上面的事件，再进行这个事件 btn.]]></description></item><item><title>【慕课网】Promise 入门教程</title><link>http://mengsha97.github.io/posts/imooc-promise/</link><pubDate>Mon, 02 Mar 2020 14:27:33 +0000</pubDate><author><name>Simona</name><uri>https://github.com/Mengsha97</uri><email>laimengsha@qq.com</email></author><guid>http://mengsha97.github.io/posts/imooc-promise/</guid><description>讲师：翟路佳 课程：https://www.imooc.com/learn/949 代码：https://github.com/merrier/imooc-promise-sample 第一章 异步的问题 1-1 课程介绍 了解 Promise 诞生的历史背景 学会使用 Promise 解决异步回调带来的问题 掌握 Promise 的进阶用法 1-2 Promise 释义按照用途来解释
主要用于异步计算 可以将异步操作队列化，按照期望的顺序执行，返回复合预期的结果。 可以在对象之间传递和操作 Promise，帮助我们处理队列。 1-3 异步产生的原因 JavaScript 包含大量异步操作 有了 Node.js 之后，对异步的依赖进一步加剧了（无阻塞高并发，是 Node.js 的招牌；异步操作是其保障；大量操作依赖回调函数） 异步操作的常见语法 事件侦听与相应 回调 1-4 异步回调的问题 不好维护 异步回调函数会在一个新的栈运行，所以无法获取之前的栈的信息；之前的栈也无法捕获这个栈抛出的错误信息。所以没法正常使用 try catch 总结如下
嵌套层次很深，难以维护 无法正常使用 return 和 throw 无法正常检索堆栈信息 多个回调之间难以建立联系 第二章 Promise 入门 2-1 Promise 简介使用之前，初始化 Promise 实例
new Promise( /* 执行器executor */ function (resolve, reject) { //一段耗时很长的异步操作 resolve(); //数据处理完成 reject(); //数据处理出错 } ).</description></item></channel></rss>