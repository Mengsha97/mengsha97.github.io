[{"categories":["weex"],"content":"讲师：你好_方老师 课程：https://www.imooc.com/learn/948 ","date":"2020-12-13","objectID":"/posts/imooc-weex-entry/:0:0","tags":["weex","APP开发","vue","rax"],"title":"【慕课网】Weex入门","uri":"/posts/imooc-weex-entry/"},{"categories":["weex"],"content":"第一章 weex 介绍 ","date":"2020-12-13","objectID":"/posts/imooc-weex-entry/:1:0","tags":["weex","APP开发","vue","rax"],"title":"【慕课网】Weex入门","uri":"/posts/imooc-weex-entry/"},{"categories":["weex"],"content":"1-1 weex 介绍 weex 介绍 2016 年 4 月阿里巴巴在 Qcon 大会上宣布开源的一套跨平台移动开发工具 主要解决了频繁发版和多端研发的两大痛点，同时解决了前端语言性能差和显示效果受限的问题 只需要在自己 app 中嵌入 weex 的 sdk，就可以通过撰写 html/css/javascript 来开发 native 级别的 weex 界面，weex 界面的生成码其实就是一段很小的 js，可以像发布网页一样轻松部署在服务端，然后在 app 中请求执行 weex 优势 支持 ES6 规范 性能优异，开发简洁标准，体积小巧 跨平台 weex 调试工具 weexplayground ","date":"2020-12-13","objectID":"/posts/imooc-weex-entry/:1:1","tags":["weex","APP开发","vue","rax"],"title":"【慕课网】Weex入门","uri":"/posts/imooc-weex-entry/"},{"categories":["weex"],"content":"1-2weex 开发环境的搭建 安装 node.js npm install -g weex-toolkit weex init (project.name) cd (project.name) npm install npm run serve //开启服务 npm run dev //开启 APP npm run debug //开启调试 ","date":"2020-12-13","objectID":"/posts/imooc-weex-entry/:1:2","tags":["weex","APP开发","vue","rax"],"title":"【慕课网】Weex入门","uri":"/posts/imooc-weex-entry/"},{"categories":["weex"],"content":"第二章 weex 通用样式 ","date":"2020-12-13","objectID":"/posts/imooc-weex-entry/:2:0","tags":["weex","APP开发","vue","rax"],"title":"【慕课网】Weex入门","uri":"/posts/imooc-weex-entry/"},{"categories":["weex"],"content":"2-1 weex 通用样式介绍 适配和缩略 weex 对于长度值目前只支持像素值，不支持相对单位(em,rem);适配以 750px 标准 屏幕适配系数，使用 scale 设定边框，border 不支持简写，如 border:1px solid #ffffff; 设定背景色不支持 background:#000000;这个写法，需要写成 background-color:#000000; ","date":"2020-12-13","objectID":"/posts/imooc-weex-entry/:2:1","tags":["weex","APP开发","vue","rax"],"title":"【慕课网】Weex入门","uri":"/posts/imooc-weex-entry/"},{"categories":["weex"],"content":"2-2 weex 通用组件的介绍 定位 weex 支持 position 定位，relative|absolute|fixed|sticky，默认值为 relative weex 目前不支持 z-index 设置元素层级关系，但靠后的元素层级更高，因此，对于层级高的元素，可将其排列在后面 如果定位元素超过容器边界，在 Android 下，超出部分将不可见，原因在于 Android 端元素 overflow 默认值为 hidden 其余需要注意的地方 weex 支持线性渐变 linner-gradient 不支持 radial-gradient 径向渐变 weex 中 box-shadow 仅仅支持 IOS 目前\u003cimage\u003e组件无法定义一个或几个角的 border-radius，只对 IOS 有效，对 Android 无效 weex 中，flexbox 是默认并且唯一的布局模型，每个元素都默认拥有了 display:flex 属性 ","date":"2020-12-13","objectID":"/posts/imooc-weex-entry/:2:2","tags":["weex","APP开发","vue","rax"],"title":"【慕课网】Weex入门","uri":"/posts/imooc-weex-entry/"},{"categories":["weex"],"content":"第三章 weex 内建组件 ","date":"2020-12-13","objectID":"/posts/imooc-weex-entry/:3:0","tags":["weex","APP开发","vue","rax"],"title":"【慕课网】Weex入门","uri":"/posts/imooc-weex-entry/"},{"categories":["weex"],"content":"3-1 \u003ca\u003e组件 weex 中 a 组件定义了指向 weex 页面打包后的一个 js 地址 a 组件无法跳转 html 页面（后面会介绍怎么跳转 html 页面） 组件中无法添加文本，需要在其中加上 text 组件才能添加文本 此组件支持除自己外的所有 weex 组件作为子组件 支持所有通用样式 请不要为\u003ca\u003e组件添加 click 事件 ","date":"2020-12-13","objectID":"/posts/imooc-weex-entry/:3:1","tags":["weex","APP开发","vue","rax"],"title":"【慕课网】Weex入门","uri":"/posts/imooc-weex-entry/"},{"categories":["weex"],"content":"3-2 \u003cweb\u003e组件 \u003cweb\u003e组件用于在页面中嵌入一张网页；src 用以指定资源地址 不支持任何子组件 pagestart，\u003cweb\u003e组件开始加载时执行 pagefinish，\u003cweb\u003e组件完成加载时执行 error，\u003cweb\u003e组件加载错误时执行 ","date":"2020-12-13","objectID":"/posts/imooc-weex-entry/:3:2","tags":["weex","APP开发","vue","rax"],"title":"【慕课网】Weex入门","uri":"/posts/imooc-weex-entry/"},{"categories":["weex"],"content":"3-3 \u003cwebview\u003e组件 weex 内建模块 \u003cwebview\u003e模块 一系列\u003cweb\u003e组件的操作接口，可以通过 this.$refs.el 来获取元素的引用 引入 const webview = weex.requireModule(\"webview\"); API goBack(webElement)，加载历史记录里的前一个资源地址 goForward(webElement)，加载历史记录里的下一个资源地址 reload(webElement)，刷新当前页面 ","date":"2020-12-13","objectID":"/posts/imooc-weex-entry/:3:3","tags":["weex","APP开发","vue","rax"],"title":"【慕课网】Weex入门","uri":"/posts/imooc-weex-entry/"},{"categories":["weex"],"content":"3-4 \u003clist\u003e组件——实现下拉刷新和上拉加载 \u003clist\u003e组件 \u003clist\u003e组件是垂直列表功能的核心组件 \u003ccell\u003e组件，列表中的子项；类似于 html 中的 ul 和 li 的关系 \u003cheader\u003e到达屏幕顶部时，吸附在屏幕顶部 \u003crefresh\u003e给列表加下拉刷新的功能 loadmore 事件，loadmoreoffset{number}触发事件所需距离 scroll 事件列表滚动时触发该事件 offset-accuracy{number}控制 scroll 事件发生的频率。（默认 10px） \u003crefresh\u003e组件 用于提供下拉加载功能。\u003cscroller\u003e和\u003clist\u003e的子组件，只有被这两个组件包含时才能正常展示 refresh 事件，当 list 组件和 scroller 组件被下拉时触发 pullingdown 事件 ","date":"2020-12-13","objectID":"/posts/imooc-weex-entry/:3:4","tags":["weex","APP开发","vue","rax"],"title":"【慕课网】Weex入门","uri":"/posts/imooc-weex-entry/"},{"categories":["weex"],"content":"vue 基础知识 ","date":"2020-12-13","objectID":"/posts/imooc-weex-entry/:4:0","tags":["weex","APP开发","vue","rax"],"title":"【慕课网】Weex入门","uri":"/posts/imooc-weex-entry/"},{"categories":["weex"],"content":"vue-router 介绍 vue-router 介绍 针对 vue.js 开发的一个前端路由工具，可以方便快速的开发单页应用 vue-router 是以 vue.js 插件的形式存在的，我们在使用 vue-router 之前需要先引入 vue 文件。因为 vue 是 weex 内置的前端框架，所以不需要再引入一次了，只需要引入 vue-router 并注册就可以了 我们需要在 template 模板中添加\u003crouter-view\u003e的方式定了路由的出口，路由匹配到了对应的 vue 文件就会替换这个标签 在我们向应用中注册 router 之前，需要先创建一个路由实例，并且配置对应的路由规则 在应用中注入路由功能，我们还需要给入口组件添加 router 属性，使应用和路由建立联系 ","date":"2020-12-13","objectID":"/posts/imooc-weex-entry/:4:1","tags":["weex","APP开发","vue","rax"],"title":"【慕课网】Weex入门","uri":"/posts/imooc-weex-entry/"},{"categories":["课程记录"],"content":"讲师：谢成 课程：https://www.imooc.com/learn/1246 ","date":"2020-12-05","objectID":"/posts/imooc-es6fast/:0:0","tags":["es6","javsscript"],"title":"【慕课网】带你快速入坑ES6","uri":"/posts/imooc-es6fast/"},{"categories":["课程记录"],"content":"第一章 ","date":"2020-12-05","objectID":"/posts/imooc-es6fast/:1:0","tags":["es6","javsscript"],"title":"【慕课网】带你快速入坑ES6","uri":"/posts/imooc-es6fast/"},{"categories":["课程记录"],"content":"1-1 ES6 学习的正确姿势 ES6 和 ES2015 指的是同一个版本 安装 VSCode 编辑器的插件——Live Server（差量即时编译） ","date":"2020-12-05","objectID":"/posts/imooc-es6fast/:1:1","tags":["es6","javsscript"],"title":"【慕课网】带你快速入坑ES6","uri":"/posts/imooc-es6fast/"},{"categories":["课程记录"],"content":"第二章 ES6 特性入坑 ","date":"2020-12-05","objectID":"/posts/imooc-es6fast/:2:0","tags":["es6","javsscript"],"title":"【慕课网】带你快速入坑ES6","uri":"/posts/imooc-es6fast/"},{"categories":["课程记录"],"content":"2-1 JS 中可以声明常量吗 常量是什么 当前的量只可以读不可以写 ES5 里声明常量的方法 Object.defineProperty(window, \"es\", { value: \"es6\", writable: false, //不可写 }); console.log(res); //es6 es = \"es2015\"; //不会报错 console.log(res); //es6 ES6 声明常量要注意的 声明 const 常量时就要赋值，不然会报错； 通过 const 声明的常量不允许重复声明； 通过 const 声明的常量不属于顶层对象 window，这样不会污染全局变量； 当用 const 声明常量时，不存在变量提升，即下面所写会报错，要先定义，后使用 console.log(str); const str = \"es6\"; const 变量具有块级作用域 ","date":"2020-12-05","objectID":"/posts/imooc-es6fast/:2:1","tags":["es6","javsscript"],"title":"【慕课网】带你快速入坑ES6","uri":"/posts/imooc-es6fast/"},{"categories":["课程记录"],"content":"2-2 const 声明的常量真的不可以改变吗 例 1 对象的属性被改变 const esObj = { name: \"es6\", year: 2015, }; esObj.name = \"es2015\"; console.log(esObj); //{name:'es2015',year:2015} 例 2 数组元素被改变 const arr = [\"es6\", \"es7\", \"es8\"]; arr[0] = \"es2015\"; console.log(arr); //['es2015','es7','es8'] 数据存储类型 栈存储：数字、字符串、数组或常量的等引用数据类型 堆存储：数组、对象 怎样使 const 声明的对象和数组内部不可改变？ 方法一：Object.freeze() 对象和数组都可以被冻结 const esObj = { name: \"es6\", year: 2015, }; Object.freeze(esObg); //冻结对象 esObj.name = \"es2015\"; //成功 console.log(esObj); //{name:'es6',year:2015} 只能做浅层次冻结 const esObj = { name: \"es6\", year: \"2015\", extension: [\"es7\", \"es8\", \"es9\"], }; Object.freeze(esObg); esObj.extension[0] = \"es2016\"; console.log(esObj); //{name:'es6',year:'2015',extension:['es2016','es8','es9']} 封装一个函数，深层冻结 function myFreeze(obj) { Object.freeze(obj); Object.keys(obj).forEach(function (key) { if (typeof obj[key] === \"object\") { myFreeze(obj[key]); } }); } 什么时候用 let，什么时候用 const 默认情况下优先使用 const，只有当前的值需要改变的时候才用 let ","date":"2020-12-05","objectID":"/posts/imooc-es6fast/:2:2","tags":["es6","javsscript"],"title":"【慕课网】带你快速入坑ES6","uri":"/posts/imooc-es6fast/"},{"categories":["课程记录"],"content":"2-3 函数有更简单的写法吗（箭头函数） const sum3 = (x, y) =\u003e { return x + y; }; //也可以这样写 const sum4 = (x, y) =\u003e x + y; const sum5 = (x) =\u003e x + 1; 箭头函数里面没有 this，它会从上层作用域内找 this ","date":"2020-12-05","objectID":"/posts/imooc-es6fast/:2:3","tags":["es6","javsscript"],"title":"【慕课网】带你快速入坑ES6","uri":"/posts/imooc-es6fast/"},{"categories":["课程记录"],"content":"2-4 箭头函数任何场景都可以使用吗 对象里的方法 const obj = { name: \"xiecheng\", showName: function () { console.log(\"我的名字是：\" + this.name); }, showName1: () =\u003e { console.log(\"我的名字是：\" + this.name); }, showName2() { //ES对象里面方法的简写形式 console.log(\"我的名字是：\" + this.name); }, }; obj.showName(); //我的名字是：xiecheng obj.showName1(); //我的名字是： obj.showName2(); //我的名字是：xiecheng 箭头函数里的 this 并没有指向对象，而是指向了上一层的 this，在这里是 window 使用 arguments 获取形参 function sum2(x, y) { console.log(arguments); } sum2(2, 3); //0:2 1:3 const sum3 = (x, y) =\u003e { console.log(arguments); return x + y; }; sum3(3, 4); //报错 即箭头函数里不能使用 arguments 定义类 //类，ES5写法 function Course(name, price) { (this.name = name), (this.price = price); } //类，箭头函数写法 const Course = (name, price) =\u003e { this.name = name; thia.price = price; }; const c1 = new Course(\"es\", 500); console.log(c1); //报错，Course is not a constructor 不能定义原型下的方法 function Course(name, price) { (this.name = name), (this.price = price); } Course.prototype.study = function () { //改成箭头函数会报错 console.log(`我要学习${this.name},价格是${this.price}`); //模板字符串 }; const c1 = new Course(\"es\", 500); console.log(c1); c1.study(); ","date":"2020-12-05","objectID":"/posts/imooc-es6fast/:2:4","tags":["es6","javsscript"],"title":"【慕课网】带你快速入坑ES6","uri":"/posts/imooc-es6fast/"},{"categories":["课程记录"],"content":"2-5 取值有更优雅的方式吗（解构赋值） const course = { name: \"es6\", price: 500, }; //ES6之前的写法 const name = course.name; const price = course.price; console.log(name, price); //es5 500 //ES6的写法 const { name, price } = course; //解构等号左边与右边的对应的结构要完全一样 console.log(name, price); //es5 500 const courseArr = [\"es6\", \"es7\", \"es8\"]; //ES6之前的写法 const a = courseArr[0]; const b = courseArr[1]; const c = courseArr[2]; console.log(a, b, c); //es6 es7 es8 //ES6的写法 const [a, b, c] = courseArr; console.log(a, b, c); //es6 es7 es8 解构赋值接收值的常量或变量不能重复名字 const course = { name: \"es6\", price: 500, teacher: { name: \"xiecheng\", age: 34, }, }; const { name, price, teacher: { name, age }, } = course; console.log(name, price, name, age); //报错，name不能重复定义 可以通过取别名来区分 const course = { name: \"es6\", price: 500, teacher: { name: \"xiecheng\", age: 34, }, }; const { name: courseName, price, teacher: { name, age }, } = course; console.log(courseName, price, name, age); ","date":"2020-12-05","objectID":"/posts/imooc-es6fast/:2:5","tags":["es6","javsscript"],"title":"【慕课网】带你快速入坑ES6","uri":"/posts/imooc-es6fast/"},{"categories":["课程记录"],"content":"你能在项目中准确的使用解构赋值吗 把数组作为函数参数 //之前的写法 const sum = (arr) =\u003e { let result = 0; for (let i = 0; i \u003c arr.length; i++) { result += arr[i]; } return result; }; //ES6的写法 const sum = ([a, b, c]) =\u003e { return a + b + c; }; sum([1, 2, 3]); 把对象作为函数参数 const foo = ({ name, age }) =\u003e { console.log(name, age); }; foo({ name: \"张三\", age: 20, }); //设置默认值 const foo = ({ name, age, school = \"XX学校\" }) =\u003e { console.log(name, age); }; 函数返回值为对象 const foo = () =\u003e { return { name: \"张三\", age: 20, }; }; const { name, age } = foo(); console.log(name, age); 变量互换 let a = 1; let b = 2; [b, a] = [a, b]; JSON 应用 const json = '{\"name\":\"es\",\"price\":500}'; const { name, price } = JSON.parse(json); 直接对后端返回数据进行解构（Ajax 请求应用） axios.get('./data.json').then({data:{name,price}} =\u003e { console.log(name); console.log(price); }); ","date":"2020-12-05","objectID":"/posts/imooc-es6fast/:2:6","tags":["es6","javsscript"],"title":"【慕课网】带你快速入坑ES6","uri":"/posts/imooc-es6fast/"},{"categories":["课程记录"],"content":"ES6 不能被所有浏览器解析怎么办 用 Babel 将 ES6 语法转换成 ES5 语法 安装 Node.js 环境 进入到项目，初始化 package.json npm init -y 安装 npm install --save-dev babel-preset-env babel-cli 创建文件并配置：.babelrc { \"presets\": [\"env\"] } 文件转化 文件 babel src/index.js -o dist/index.js 文件夹 babel src -d dist 实时监控 babel src -w -d dist ","date":"2020-12-05","objectID":"/posts/imooc-es6fast/:2:7","tags":["es6","javsscript"],"title":"【慕课网】带你快速入坑ES6","uri":"/posts/imooc-es6fast/"},{"categories":["课程记录"],"content":"第三章 如何更好的学习 ES ","date":"2020-12-05","objectID":"/posts/imooc-es6fast/:3:0","tags":["es6","javsscript"],"title":"【慕课网】带你快速入坑ES6","uri":"/posts/imooc-es6fast/"},{"categories":["课程记录"],"content":"3-1 如何更好的学习 ES ES6 官网 http://www.ecma-international.org/ecma-262/6.0/ ES6 教师总结 http://es.xiecheng.live ES 学习建议 基础语法 应用场景 多在项目中应用 ","date":"2020-12-05","objectID":"/posts/imooc-es6fast/:3:1","tags":["es6","javsscript"],"title":"【慕课网】带你快速入坑ES6","uri":"/posts/imooc-es6fast/"},{"categories":["课程记录"],"content":"第一章 课程介绍 讲师：大谷 课程：https://www.imooc.com/learn/1285 ","date":"2020-11-22","objectID":"/posts/imooc-self-adaption/:1:0","tags":["css","mediaquery","自适应"],"title":"【慕课网】六个案例学会响应式布局","uri":"/posts/imooc-self-adaption/"},{"categories":["课程记录"],"content":"1-1 课程介绍 课程安排 CSS 中媒体查询的作用和使用方法 flex 弹性盒子的用法 rem 的作用和使用方法 响应式布局、弹性布局等六个课程案例 ","date":"2020-11-22","objectID":"/posts/imooc-self-adaption/:1:1","tags":["css","mediaquery","自适应"],"title":"【慕课网】六个案例学会响应式布局","uri":"/posts/imooc-self-adaption/"},{"categories":["课程记录"],"content":"mediaquery 媒体查询 ","date":"2020-11-22","objectID":"/posts/imooc-self-adaption/:2:0","tags":["css","mediaquery","自适应"],"title":"【慕课网】六个案例学会响应式布局","uri":"/posts/imooc-self-adaption/"},{"categories":["课程记录"],"content":"2-1 什么是媒体查询 概念：为不同尺寸的屏幕设定不同的 CSS 样式 ","date":"2020-11-22","objectID":"/posts/imooc-self-adaption/:2:1","tags":["css","mediaquery","自适应"],"title":"【慕课网】六个案例学会响应式布局","uri":"/posts/imooc-self-adaption/"},{"categories":["课程记录"],"content":"2-2 @media 常用参数 属性名称 作用 width、height 浏览器可视宽度、高度 device-width 设备屏幕的宽度 device-height 设备屏幕的高度 ","date":"2020-11-22","objectID":"/posts/imooc-self-adaption/:2:2","tags":["css","mediaquery","自适应"],"title":"【慕课网】六个案例学会响应式布局","uri":"/posts/imooc-self-adaption/"},{"categories":["课程记录"],"content":"2-3 媒体查询其他引入方式-1 \u003cstyle media=\"(min-device-width:100px) and (max-device-width:300px)\"\u003e #div0 { background-color: red; } \u003c/style\u003e ","date":"2020-11-22","objectID":"/posts/imooc-self-adaption/:2:3","tags":["css","mediaquery","自适应"],"title":"【慕课网】六个案例学会响应式布局","uri":"/posts/imooc-self-adaption/"},{"categories":["课程记录"],"content":"媒体查询其他引入方式-2 \u003clink href=\"css/css-1.css\" rel=\"stylesheet\" media=\"(min-device-width:100px) and (max-device-width:300px)\" /\u003e ","date":"2020-11-22","objectID":"/posts/imooc-self-adaption/:2:4","tags":["css","mediaquery","自适应"],"title":"【慕课网】六个案例学会响应式布局","uri":"/posts/imooc-self-adaption/"},{"categories":["课程记录"],"content":"媒体查询其他引入方式-3 @media (min-device-width: 400px) and (max-device-width: 500px) { #div0 { background-color: blue; } } ","date":"2020-11-22","objectID":"/posts/imooc-self-adaption/:2:5","tags":["css","mediaquery","自适应"],"title":"【慕课网】六个案例学会响应式布局","uri":"/posts/imooc-self-adaption/"},{"categories":["课程记录"],"content":"第三章 flex 基础与应用 ","date":"2020-11-22","objectID":"/posts/imooc-self-adaption/:3:0","tags":["css","mediaquery","自适应"],"title":"【慕课网】六个案例学会响应式布局","uri":"/posts/imooc-self-adaption/"},{"categories":["课程记录"],"content":"3-1 什么是 flex 概念：FlexiableBox 即是弹性盒子，用来进行弹性布局，可以配合 rem 处理尺寸的适配问题 ","date":"2020-11-22","objectID":"/posts/imooc-self-adaption/:3:1","tags":["css","mediaquery","自适应"],"title":"【慕课网】六个案例学会响应式布局","uri":"/posts/imooc-self-adaption/"},{"categories":["课程记录"],"content":"第四章 常用布局 ","date":"2020-11-22","objectID":"/posts/imooc-self-adaption/:4:0","tags":["css","mediaquery","自适应"],"title":"【慕课网】六个案例学会响应式布局","uri":"/posts/imooc-self-adaption/"},{"categories":["课程记录"],"content":"4-1 rem 的使用方法 概念 指相对于根元素的字体大小的单位 区别 与 em 区别，em 是相对于父元素的字体大小的单位 案例 /* 初始化根字体相当于设置 html{font-size:} */ var c = () =\u003e { let w = document.documentElement.clientWidth; /* 获取设备的宽度*/ let n = 20 * (w / 320) \u003e 40 ? 40 + \"px\" : 20(w / 320) + \"px\"; /* 假设基准字体大小为20px；基准屏幕宽度为320px；在各种尺寸里字体大小不大于40（这是常识） */ document.documentElement.style.fontSize = n; }; window.addEventListener(\"load\", c); window.addEventListener(\"resize\", c); ","date":"2020-11-22","objectID":"/posts/imooc-self-adaption/:4:1","tags":["css","mediaquery","自适应"],"title":"【慕课网】六个案例学会响应式布局","uri":"/posts/imooc-self-adaption/"},{"categories":["课程记录"],"content":"4-2 自适应布局 布局特点 不同设备对应不同的 html；局部自适应即不同的设备用不同的页面或局部伸缩 设计思路 判断设备的类型或控制局部的变化 \u003cscript type=\"text/javascript\"\u003e var redirect=()=\u003e{ let userAgent = navigator.userAgent.toLowerCase(); //正则表达式，判断设备类型 let device = /ipad|iphone|midp|rv:1.2.3.4|ucweb|android|window ce|window mobile/; if(device.test(userAgent)){ //跳转移动端页面 window.location.href=\"move.html\"; }else{ //跳转PC端页面 window.location.href=\"pc.html\"; } } redirect() \u003c/script\u003e ","date":"2020-11-22","objectID":"/posts/imooc-self-adaption/:4:2","tags":["css","mediaquery","自适应"],"title":"【慕课网】六个案例学会响应式布局","uri":"/posts/imooc-self-adaption/"},{"categories":["课程记录"],"content":"4-3 响应式布局 布局特点 确保一个页面在所有终端上，都能显示出令人满意的效果（重 CSS） 设计思路 使用%或 rem 作为单位，此处采用%为单位 案例 一定要加入的一句 \u003cmeta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,user-scalable=0\" /\u003e width 决定宽度；initial-scale 控制在默认情况下显示原始尺寸；user-scalable 代表是否允许缩放，设置为 0 表示不使用浏览器自身是缩放 ","date":"2020-11-22","objectID":"/posts/imooc-self-adaption/:4:3","tags":["css","mediaquery","自适应"],"title":"【慕课网】六个案例学会响应式布局","uri":"/posts/imooc-self-adaption/"},{"categories":["课程记录"],"content":"4-4 rem 弹性布局 布局特点 为了保证在各种屏幕上的不失真，就要根据实际屏幕宽度做等比例换算，即一套方案，使不同尺寸、分辨率的视口，都能呈现出较好的效果。 设计思路 使用%或 rem 作为单位，此处采用 rem 为单位 ","date":"2020-11-22","objectID":"/posts/imooc-self-adaption/:4:4","tags":["css","mediaquery","自适应"],"title":"【慕课网】六个案例学会响应式布局","uri":"/posts/imooc-self-adaption/"},{"categories":["错误记录"],"content":"这是将 yyyy-mm-dd 转换成 yyyy/mm/dd 并通过 getTime()获得时间戳的例子，上面这段用正则转换是可以的，但是下面那个就不行，要好好学习下正则表达式了 （苹果手机可以显示） let strTime = y + \"-\" + m + \"-\" + d; this.endTime = new Date(Date.parse(strTime.replace(/-/g, \"/\"))).getTime() - new Date().getTime(); （苹果手机不能显示） let strTime = y + \"-\" + m + \"-\" + d; this.endTime = new Date(y + \"/\" + m + \"/\" + d).getTime() - new Date().getTime(); ","date":"2020-08-27","objectID":"/posts/js-error/:0:0","tags":["javascript","兼容性","苹果","安卓"],"title":"【错误记录】苹果手机关于Date的某些操作兼容性问题","uri":"/posts/js-error/"},{"categories":["微信小程序"],"content":"用来记录一下在微信小程序上开发出现的问题（大部分是通过 uniapp） ","date":"2020-08-27","objectID":"/posts/applet-of-wechat-dev/:0:0","tags":["wechat","applet"],"title":"【学习记录】微信小程序开发技巧","uri":"/posts/applet-of-wechat-dev/"},{"categories":["微信小程序"],"content":"2020 年 8 月 27 日 在微信小程序中用{{变量名}}来展示变量时，用函数进行处理，是无效的，而且会不显示（应该是微信小程序开发生态的问题） 微信每次用 canvas 画图（如果有要用到的远程图片）之前都要先把图片下载下来，一个比较方便的办法是将图片保存到本地（即保存图片的本地地址，通过 uni.request 等方法），省得每次要用的时候都要重新下载 ","date":"2020-08-27","objectID":"/posts/applet-of-wechat-dev/:1:0","tags":["wechat","applet"],"title":"【学习记录】微信小程序开发技巧","uri":"/posts/applet-of-wechat-dev/"},{"categories":["uniapp"],"content":"公司主要用的是 uniapp 来开发前端，所以开这篇博客来记录一下我在开发中遇到的一些问题及解决方法、uniapp 的缺点不足及避免的方法等 ","date":"2020-08-27","objectID":"/posts/uni-develop/:0:0","tags":["uniapp","develop"],"title":"【uniapp】uniapp开发技巧","uri":"/posts/uni-develop/"},{"categories":["uniapp"],"content":"2020 年 8 月 27 日 cover-view 不能用 flex，不能设置 backgroundImage，不能用 v-if(之后是否能解决用我们拭目以待) 在\u003crouter-link\u003e标签上定义样式，在 h5 中有效，但是在微信小程序中无效 用 scroll-view 组件并且要动态改变 scrollTop 时，要用下面的方法改变 this.scrollTop = this.nowScrollTop; this.$nextTick(() =\u003e { this.scrollTop = this.navTop + this.goodsHeght; }); 即要先把现在的高度赋给 scrollTop 再重新把要赋的值赋给它，这是因为，在页面进行滚动时，scrollTop 的值不会发生变化，如果要赋的值跟 scrollTop 本身的值相同，则 scroll-view 不进行滚动 ","date":"2020-08-27","objectID":"/posts/uni-develop/:1:0","tags":["uniapp","develop"],"title":"【uniapp】uniapp开发技巧","uri":"/posts/uni-develop/"},{"categories":["学习记录"],"content":" CSS display 的值是 none。 type=“hidden\"的表单元素。 宽度和高度都显式设置为 0。 一个祖先元素是隐藏的，该元素是不会在页面上显示 CSS visibility 的值是 hidden CSS opacity 的指是 0 如果元素中占据文档中一定的空间,元素被认为是可见的。 可见元素的宽度或高度，是大于零。 元素的 visibility: hidden 或 opacity: 0 被认为是可见的，因为他们仍然占用空间布局。 ","date":"2020-07-19","objectID":"/posts/hideelement/:0:0","tags":["CSS"],"title":"【学习记录】用CSS隐藏一个元素的方法","uri":"/posts/hideelement/"},{"categories":["学习记录"],"content":" IE 会将注释节点实现为元素，所以在 IE 中调用 getElementsByTagName 里面会包含注释节点，这个通常是不应该的 getElementById 的参数在 IE8 及较低的版本不区分大小写 IE7 及较低的版本中，表单元素中，如果表单 A 的 name 属性名用了另一个元素 B 的 ID 名并且 A 在 B 之前，那么 getElementById 会选中 A IE8 及较低的版本，浏览器不支持 getElementsByClassName ","date":"2020-07-19","objectID":"/posts/js-getelementby/:0:0","tags":["js","getElementByTagName","getElementById"],"title":"【学习记录】原生选择器的兼容性问题","uri":"/posts/js-getelementby/"},{"categories":["uni-app"],"content":"来自：https://uniapp.dcloud.io/frame?id=css%e5%8f%98%e9%87%8f 在开发过程中，既不想打开 NavigationStyle，又想让页面空出手机标签的位置，可以使用 css 变量———–status-bar-height 使用方法： \u003ctemplate\u003e \u003c!-- HBuilderX 2.6.3+ 新增 page-meta, 详情：https://uniapp.dcloud.io/component/page-meta --\u003e \u003cpage-meta\u003e \u003cnavigation-bar /\u003e \u003c/page-meta\u003e \u003cview\u003e \u003cview class=\"status_bar\"\u003e \u003c!-- 这里是状态栏 --\u003e \u003c/view\u003e \u003cview\u003e 状态栏下的文字 \u003c/view\u003e \u003c/view\u003e \u003c/template\u003e \u003cstyle\u003e .status_bar { height: var(--status-bar-height); width: 100%; } \u003c/style\u003e 这里得出来的变量单位是 px，也可以直接用在标签上 另外还有其他两个 CSS 变量，如下 CSS 变量 描述 App 小程序 H5 –status-bar-height 系统状态栏高度 系统状态栏高度、nvue 注意见下 25px 0 –window-top 内容区域距离顶部的距离 0 0 NavigationBar 的高度 –window-bottom 内容区域距离底部的距离 0 0 TabBar 的高度 ","date":"2020-05-12","objectID":"/posts/css-variable/:0:0","tags":["css"],"title":"【uniapp】关于uniapp中的CSS变量","uri":"/posts/css-variable/"},{"categories":["课程记录"],"content":"讲师：KingJ 课程：https://www.imooc.com/learn/1189 ","date":"2020-04-15","objectID":"/posts/imooc-csslayout/:0:0","tags":["css","layout"],"title":"【慕课网】一课全面掌握主流CSS布局","uri":"/posts/imooc-csslayout/"},{"categories":["课程记录"],"content":"居中布局 ","date":"2020-04-15","objectID":"/posts/imooc-csslayout/:1:0","tags":["css","layout"],"title":"【慕课网】一课全面掌握主流CSS布局","uri":"/posts/imooc-csslayout/"},{"categories":["课程记录"],"content":"水平居中布局 指当前元素在父级元素容器中，水平方向是居中显示的 inline-block+text-align 属性配合使用 关键代码 \u003cdiv id=\"parent\"\u003e \u003cdiv id=\"child\"\u003e子级元素\u003c/div\u003e \u003c/div\u003e #parent{ text-align:center; } #child{ display:inline-block; } 属性的说明 text-align 属性：是为文本内容设置对齐方式 left：左对齐 center：居中对齐 right：右对齐 display 属性： block：块级元素 inline：内联元素（text-align 属性有效） 当 display 设置为 inline 时，css 中的 width 和 height 属性是无效的 inline-block：行内块级元素（块级+内联） width 和 height 属性值是有效的 优缺点 优点：浏览器兼容性比较好 缺点：text-align 属性具有继承性，导致子级元素的文本也是居中显示的 解决方式：可以在子级元素中设置 text-align 为想要的效果，这样会覆盖父级元素设置的效果 table+margin 属性配合使用 关键代码 \u003cdiv class=\"parent\"\u003e \u003cdiv class=\"child\"\u003e子级元素\u003c/div\u003e \u003c/div\u003e .child{ display:table; margin:0 auto; } 属性说明 margin 属性：外边距 一个值——上右下左四个方向 两个值——第一个表示上下，第二个表示左右 三个值——第一个值表示上，第二个值表示左右，第三个值表示下 auto：表示浏览器自动分配，浏览器会等分左右外边距 四个值——分别代表上右下左 display 设置为 block 和 table 都可水平居中 设置为 inline 并且在块中添加文字，不会水平居中， 设置为 inline-block 也不会水平居中 优缺点 优点：只需要对子级元素进行设置就可以实现水平方向居中效果 缺点：如果子级元素脱离文档流，导致 margin 属性的值无效 css 中脱离文档流的方式 设置 float 设置 position 为 absolute 设置 position 为 fixed absolute+transform 属性配合使用 关键代码 \u003cdiv class=\"parent\"\u003e \u003cdiv class=\"child\"\u003e居中\u003c/div\u003e \u003c/div\u003e .parent{ position:relative; } .child{ position:absolute; left:50%; transform:translateX(-50%); } 属性说明 当把当前元素设置为绝对定位之后： 如果父级元素没有开启定位的话，当前元素是相对于页面定位的 如果父级元素开启了定位的话，当前元素是相对于父级元素定位的 除了 position 的默认值 static，其它值都是开启定位 left:50%——子级元素的左边相对于父级元素左边的距离是 50% transform:translateX(-50%)——子级元素向左平移自己宽度的 50%单位，这样正好就居中了，这个 50%也可以写成子级元素宽度的一半，但是写 50%更好一些 优缺点 优点：父级元素是否脱离文档流，不影响子级元素水平居中效果 缺点：transform 属性是 css3 中新增属性，浏览器支持情况不好 不仅仅只有这三种解决方案，但是这三种是比较常见的 ","date":"2020-04-15","objectID":"/posts/imooc-csslayout/:1:1","tags":["css","layout"],"title":"【慕课网】一课全面掌握主流CSS布局","uri":"/posts/imooc-csslayout/"},{"categories":["课程记录"],"content":"垂直居中布局 垂直居中布局就是指当前元素在父级元素容器中，垂直方向是居中显示的 table-cell+vertical-algin 属性配合使用 关键代码 \u003cdiv class=\"parent\"\u003e \u003cdiv class=\"child\"\u003e居中\u003c/div\u003e \u003c/div\u003e .parent{ display:table-cell; vertical-align:middle; } 属性说明 vertical-align 属性：用于设置文本内容的垂直方向对齐方式 top：顶部对齐 middle：居中对齐 bottom：底部对齐 display 属性： table：设置当前元素为\u003ctable\u003e元素效果 table-cell：设置当前元素为\u003ctd\u003e元素（单元格）效果 这样就使得 vertical-align 设置居中对齐有效了 优缺点 优点：浏览器兼容性比较好 缺点：vertical-align 属性具有继承性，导致父级元素的文本也是居中显示的 absolute+transform 属性配合使用 关键代码 \u003cdiv class=\"parent\u003e \u003cdiv class=\"child\"\u003e居中\u003c/div\u003e \u003c/div\u003e .parent{ position:relative; } .child{ position:absolute; top:50%; transform:translateY(-50%); } 属性说明 参照水平居中的第三种解决方案 优缺点 优点：无论父级元素是否脱离文档流，不影响子级元素垂直居中效果 缺点：transform 属性是 CSS3 中新增属性，浏览器支持情况不好 ","date":"2020-04-15","objectID":"/posts/imooc-csslayout/:1:2","tags":["css","layout"],"title":"【慕课网】一课全面掌握主流CSS布局","uri":"/posts/imooc-csslayout/"},{"categories":["课程记录"],"content":"居中布局（水平+垂直） 居中布局实际上就是既要水平方向居中，也要垂直方向居中 table+margin 实现水平方向居中,table-cell+vertical-align 实现垂直方向居中 去上文找，子级元素的 display 最好设置为 block（即默认值） absolute+transform 实现水平方向和垂直方向居中 如果不考虑浏览器兼容性，是优于上一种方法的 ","date":"2020-04-15","objectID":"/posts/imooc-csslayout/:1:3","tags":["css","layout"],"title":"【慕课网】一课全面掌握主流CSS布局","uri":"/posts/imooc-csslayout/"},{"categories":["课程记录"],"content":"多列布局 简单来说，多列布局就是几个元素呈现水平方式排列的效果 ","date":"2020-04-15","objectID":"/posts/imooc-csslayout/:2:0","tags":["css","layout"],"title":"【慕课网】一课全面掌握主流CSS布局","uri":"/posts/imooc-csslayout/"},{"categories":["课程记录"],"content":"两列布局 两列布局一般情况下是指定宽+自适应布局，两列中左列是确定的宽度，右列是自动填满剩余所有空间的一种布局效果 float+margin 属性配合使用 关键代码 \u003cdiv class=\"parent\"\u003e \u003cdiv class=\"left\"\u003e左：定宽\u003c/div\u003e \u003cdiv class=\"right\"\u003e右：自适应\u003c/div\u003e \u003c/div\u003e .left{ width:100px; float:left; } .right{ margin-left:100px; } 属性说明 如果只给左列设置 float:left，视觉上是实现了两列布局，但是实际上是左列把右列的一部分给覆盖了，所以要给右列设置 margin-left:（左列的宽度） 优缺点 优点：实现方式简单 缺点： 自适应元素的 margin 属性值需要与定宽元素的属性值保持一致 定宽元素浮动与自适应元素不浮动导致浏览器兼容性不好（老版本浏览器中会有空白） 若在自适应这列中存在子级元素或后代元素，并且使用了清除浮动(clear)，显示是有问题的 float+margin 属性配合使用（优化版本） 关键代码 \u003cdiv class=\"parent\"\u003e \u003cdiv class=\"left\"\u003e左：定宽\u003c/div\u003e \u003cdiv class=\"right-fix\"\u003e \u003cdiv class=\"right\"\u003e右：自适应\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e .left{ position:relative; } .right-fix{ float:right; width:100%; margin-left:-100px; } float+overflow 属性配合使用 关键代码 \u003cdiv class=\"parent\"\u003e \u003cdiv class=\"left\"\u003e左：定宽\u003c/div\u003e \u003cdiv class=\"right\"\u003e右：自适应\u003c/div\u003e \u003c/div\u003e .left{ width:100px; float:left; } .right{ overflow:hidden; } 属性说明 overflow:hidden 在此处的作用是开启 BFC 模式 当前元素的内部环境与外界完全隔离 优缺点 优点： 上述解决方案中的问题在此处解决方案中都没有 因为开启了 BFC 模式，所以不存在老版本中出现空白的情况 缺点： overflow 属性不不仅解决了两列布局问题，同时设置了内容溢出的情况，比如这时一旦右列出现内容，就会被隐藏 display 属性的 table 相关值使用 关键代码 \u003cdiv class=\"parent\"\u003e \u003cdiv class=\"left\"\u003e左：定宽\u003c/div\u003e \u003cdiv class=\"right\"\u003e右：自适应\u003c/div\u003e \u003c/div\u003e .parent{ display:table; table-layout:fixed; } .left,.right{ display:table-cell; } .left{ width:100px; } 属性说明 parent 的属性设置为 display:table;会使表格的单元格自动分配，默认是等分，如果一列设置为定宽，那么另一列会自适应 表格会出现双边框，所以 table-layout:fixed 可以解决该问题 优缺点 优点：浏览器兼容性比较好 缺点：将所有元素的 display 属性设置为 table 相关值，受到相应制约 ","date":"2020-04-15","objectID":"/posts/imooc-csslayout/:2:1","tags":["css","layout"],"title":"【慕课网】一课全面掌握主流CSS布局","uri":"/posts/imooc-csslayout/"},{"categories":["课程记录"],"content":"三列布局 三列布局一般情况下是指三列中左边两列是确定的宽度，右边一列是自动填满剩余所有空间的一种布局效果。 定宽+定宽+自适应 定宽+自适应+定宽 float+margin 属性配合使用 float+overflow 属性配合使用 display 属性的 table 相关值使用 同两列布局没有差异 ","date":"2020-04-15","objectID":"/posts/imooc-csslayout/:2:2","tags":["css","layout"],"title":"【慕课网】一课全面掌握主流CSS布局","uri":"/posts/imooc-csslayout/"},{"categories":["课程记录"],"content":"圣杯布局 又称三行三列布局，是一个完整页面的布局。圣杯布局注意实现中间主题部分中的左右定宽+中间自适应的布局效果。 解决方案一 关键代码 #left{ float:left; } #center{ margin-left:400px; margin-right:400px; } #right{ float:right; } 属性说明 如果 center 只设置 margin-left 和 margin-right，那么会出现问题如下： 问题出现的原因是：当兄弟元素中，前面的没有浮动，而后面的浮动了，那么浮动的元素是不允许超过前面的元素的，所以这两个还得是垂直方向排列 解决方法，将浮动的元素与不浮动的元素调换位置，但是实际显示的还是浮动的元素在后面 优缺点 center 作为页面的核心，数据（主要内容）被放在最后面，不利于搜索引擎抓取 解决方案二 关键代码 #parent{ /* 解决高度坍塌 */ height: 300px; /* left元素的宽度 */ margin-left: 400px; /* right元素的宽度 */ margin-right: 400px; } #left, #center, #right { height: 300px; float: left; } #left, #right { width: 400px; } #left { background-color: #c9394a; /* 将当前元素从当前行移动到上一行同一位置，刚好父级宽度的百分之百*/ margin-left: -100%; /* 开启定位，这样可以使用left属性 */ position: relative; /* 再移动到自己的宽度值*/ left: -400px; } #center { /* 为父级元素宽度的百分之百 */ width: 100%; background-color: green; } #right { background-color: #cccccc; /* 刚好移动到上一行最右边的位置 */ margin-left: -400px; position: relative; /* 再往右移动自己的定宽 */ right: -400px; } \u003cdiv id=\"parent\"\u003e \u003cdiv id=\"center\"\u003e\u003c/div\u003e \u003cdiv id=\"left\"\u003e\u003c/div\u003e \u003cdiv id=\"right\"\u003e\u003c/div\u003e \u003c/div\u003e 优缺点 优点：center 放在前面，有利于搜索引擎抓取 缺点：稍稍有点复杂 ","date":"2020-04-15","objectID":"/posts/imooc-csslayout/:2:3","tags":["css","layout"],"title":"【慕课网】一课全面掌握主流CSS布局","uri":"/posts/imooc-csslayout/"},{"categories":["课程记录"],"content":"双飞翼布局 双飞翼布局最早是淘宝团队提出，是针对圣杯布局的优化解决方案。主要是优化了圣杯布局中开启定位的问题 解决方案 关键代码 #parent { /* 解决高度坍塌 */ height: 300px; } #left, #center, #right { height: 300px; float: left; } #left, #right { width: 400px; } #left { background-color: #c9394a; /* 将当前元素从当前行移动到上一行同一位置，刚好父级宽度的百分之百*/ margin-left: -100%; } #center { /* 为父级元素宽度的百分之百 */ width: 100%; background-color: green; } #right { background-color: #cccccc; /* 刚好移动到上一行最右边的位置 */ margin-left: -400px; } #inner{ /* 解决center与两边块重合的问题 */ height: 300px; background-color: pink; /* left元素的宽度 */ margin-left: 400px; /* right元素的宽度 */ margin-right: 400px; } \u003cdiv id=\"parent\"\u003e \u003cdiv id=\"center\"\u003e \u003c!-- 解决position问题 --\u003e \u003cdiv id=\"inner\"\u003e\u003c/div\u003e \u003c/div\u003e \u003cdiv id=\"left\"\u003e\u003c/div\u003e \u003cdiv id=\"right\"\u003e\u003c/div\u003e \u003c/div\u003e ","date":"2020-04-15","objectID":"/posts/imooc-csslayout/:2:4","tags":["css","layout"],"title":"【慕课网】一课全面掌握主流CSS布局","uri":"/posts/imooc-csslayout/"},{"categories":["课程记录"],"content":"全屏布局 ","date":"2020-04-15","objectID":"/posts/imooc-csslayout/:3:0","tags":["css","layout"],"title":"【慕课网】一课全面掌握主流CSS布局","uri":"/posts/imooc-csslayout/"},{"categories":["课程记录"],"content":"等分布局 等分布局就是指一行被分为若干列，每一列的宽度是相同的值 float 属性实现等分布局效果 关键代码 .col1,.col2,.col3,.col4{ float: left; width: 25%; box-sizing: border-box; height: 300px; } .col1{ background-color: pink; } .col2{ background-color: blue; } .col3{ background-color: orange; } .col4{ background-color: green; } \u003cdiv id=\"parent\"\u003e \u003cdiv class=\"col1\"\u003e\u003cp\u003e1\u003c/p\u003e\u003c/div\u003e \u003cdiv class=\"col2\"\u003e\u003cp\u003e2\u003c/p\u003e\u003c/div\u003e \u003cdiv class=\"col3\"\u003e\u003cp\u003e3\u003c/p\u003e\u003c/div\u003e \u003cdiv class=\"col4\"\u003e\u003cp\u003e4\u003c/p\u003e\u003c/div\u003e \u003c/div\u003e display 属性的值有关 table 实现等分布局效果 关键代码 \u003cdiv id=\"parent\"\u003e \u003cdiv class=\"col\"\u003e \u003cp\u003e1\u003c/p\u003e \u003c/div\u003e \u003cdiv class=\"col\"\u003e \u003cp\u003e2\u003c/p\u003e \u003c/div\u003e \u003cdiv class=\"col\"\u003e \u003cp\u003e3\u003c/p\u003e \u003c/div\u003e \u003cdiv class=\"col\"\u003e \u003cp\u003e4\u003c/p\u003e \u003c/div\u003e \u003c/div\u003e #parent{ width: 100%; display: table; table-layout: fixed; } .col1{ display: table-cell; } ","date":"2020-04-15","objectID":"/posts/imooc-csslayout/:3:1","tags":["css","layout"],"title":"【慕课网】一课全面掌握主流CSS布局","uri":"/posts/imooc-csslayout/"},{"categories":["课程记录"],"content":"等高布局 ","date":"2020-04-15","objectID":"/posts/imooc-csslayout/:3:2","tags":["css","layout"],"title":"【慕课网】一课全面掌握主流CSS布局","uri":"/posts/imooc-csslayout/"},{"categories":["课程记录"],"content":"全屏布局 ","date":"2020-04-15","objectID":"/posts/imooc-csslayout/:3:3","tags":["css","layout"],"title":"【慕课网】一课全面掌握主流CSS布局","uri":"/posts/imooc-csslayout/"},{"categories":["面试记录"],"content":"趁着记忆还热乎，把面试中面试官提到的问题记录下来。 ","date":"2020-04-15","objectID":"/posts/interview-record/:0:0","tags":["面试"],"title":"【面试记录】","uri":"/posts/interview-record/"},{"categories":["面试记录"],"content":"浏览器 ","date":"2020-04-15","objectID":"/posts/interview-record/:1:0","tags":["面试"],"title":"【面试记录】","uri":"/posts/interview-record/"},{"categories":["面试记录"],"content":"各个浏览器的内核 （摘自百度知道） Trident 内核代表产品 Internet Explorer，又称其为 IE 内核。Trident（又称为 MSHTML），是微软开发的一种排版引擎。使用 Trident 渲染引擎的浏览器包括：IE、傲游、世界之窗浏览器、Avant、腾讯 TT、Netscape 8、NetCaptor、Sleipnir、GOSURF、GreenBrowser 和 KKman 等。 Gecko 内核代表作品 Mozilla FirefoxGecko 是一套开放源代码的、以 C++编写的网页排版引擎。Gecko 是最流行的排版引擎之一，仅次于 Trident。使用它的最著名浏览器有 Firefox、Netscape6 至 9。 WebKit 内核代表作品 Safari、Chromewebkit 是一个开源项目，包含了来自 KDE 项目和苹果公司的一些组件，主要用于 Mac OS 系统，它的特点在于源码结构清晰、渲染速度极快。缺点是对网页代码的兼容性不高，导致一些编写不标准的网页无法正常显示。主要代表作品有 Safari 和 Google 的浏览器 Chrome。 Presto 内核代表作品 OperaPresto 是由 Opera Software 开发的浏览器排版引擎，供 Opera 7.0 及以上使用。它取代了旧版 Opera 4 至 6 版本使用的 Elektra 排版引擎，包括加入动态功能，例如网页或其部分可随着 DOM 及 Script 语法的事件而重新排版。 ","date":"2020-04-15","objectID":"/posts/interview-record/:1:1","tags":["面试"],"title":"【面试记录】","uri":"/posts/interview-record/"},{"categories":["面试记录"],"content":"HTML ","date":"2020-04-15","objectID":"/posts/interview-record/:2:0","tags":["面试"],"title":"【面试记录】","uri":"/posts/interview-record/"},{"categories":["面试记录"],"content":"行内元素和块级元素有哪些 行内元素： b,big,i,small,tt abbr,acronym,cite,code,dfn,em,kbd,strong,samp,var a,bdo,br,img,map,object,q,script,span,sub,sup button,input,label,select,textarea 块级元素（加粗为 html5 新增） address,article,aside,audio, blockquote,canvas,dd,div,dl,fieldset, figcaption,figure,footer,form, header,hgroup,hr,noscript,ol,output, p,pre,section,table,tfooter,ul,video ","date":"2020-04-15","objectID":"/posts/interview-record/:2:1","tags":["面试"],"title":"【面试记录】","uri":"/posts/interview-record/"},{"categories":["面试记录"],"content":"空元素有哪些 （摘自 MDN） 一个空元素可能是 HTML，SVG，或者 MathML 里的一个不可能存在子节点的元素。 在 HTML 中，通常在一个空元素上使用一个闭标签是无效的。 空元素有： area,base,br,col, colgroup,command,embed, hr,img,input,keygen, link,meta,param, source,track,wbr ","date":"2020-04-15","objectID":"/posts/interview-record/:2:2","tags":["面试"],"title":"【面试记录】","uri":"/posts/interview-record/"},{"categories":["面试记录"],"content":"HTML5 的新特性、新标签 这篇文章介绍得很好，已经看过一遍了。 https://www.cnblogs.com/vicky1018/p/7705223.html ","date":"2020-04-15","objectID":"/posts/interview-record/:2:3","tags":["面试"],"title":"【面试记录】","uri":"/posts/interview-record/"},{"categories":["面试记录"],"content":"localStorage 和 sessionStorage localStorage——没有时间限制的数据存储 sessionStorage——针对一个 session 的数据存储，当用户关闭浏览器窗口后，数据会被删除。 ","date":"2020-04-15","objectID":"/posts/interview-record/:2:4","tags":["面试"],"title":"【面试记录】","uri":"/posts/interview-record/"},{"categories":["面试记录"],"content":"localStorage 的方法 localStorage 和 sessionStorage 可使用的 API 都相同，常用的有以下： 保存数据：localStorage.setItem(key,value) 读取数据：localStorage.getItem(key); 删除单个数据：localStorage.removeItem(key); 删除所有数据：localStorage.clear(); 得到某个索引的 key：localStorage.key(index); ","date":"2020-04-15","objectID":"/posts/interview-record/:2:5","tags":["面试"],"title":"【面试记录】","uri":"/posts/interview-record/"},{"categories":["面试记录"],"content":"CSS ","date":"2020-04-15","objectID":"/posts/interview-record/:3:0","tags":["面试"],"title":"【面试记录】","uri":"/posts/interview-record/"},{"categories":["面试记录"],"content":"CSS 实现居中的方法 待我多看点文章实现一下总结总结 ","date":"2020-04-15","objectID":"/posts/interview-record/:3:1","tags":["面试"],"title":"【面试记录】","uri":"/posts/interview-record/"},{"categories":["面试记录"],"content":"介绍盒子模型 （摘自菜鸟教程） 所有 HTML 元素可以看作盒子，在 CSS 中，“box model\"这一术语是用来设计和布局时使用。 CSS 盒模型本质上是一个盒，封装周围的 HTML 元素，它包括：边距，边框，填充，和实际内容。 盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。 一旦为页面设置了恰当的 DTD，大多数浏览器都会按照上面的图示来呈现内容。然而 IE 5 和 6 的呈现却是不正确的。根据 W3C 的规范，元素内容占据的空间是由 width 属性设置的，而内容周围的 padding 和 border 值是另外计算的。不幸的是，IE5.X 和 6 在怪异模式中使用自己的非标准模型。这些浏览器的 width 属性不是内容的宽度，而是内容、内边距和边框的宽度的总和。 虽然有方法解决这个问题。但是目前最好的解决方案是回避这个问题。也就是，不要给元素添加具有指定宽度的内边距，而是尝试将内边距或外边距添加到元素的父元素和子元素。 IE8 及更早 IE 版本不支持设置填充的宽度和边框的宽度属性。 解决 IE8 及更早版本不兼容问题可以在 HTML 页面声明 \u003c!DOCTYPE html\u003e即可。 ","date":"2020-04-15","objectID":"/posts/interview-record/:3:2","tags":["面试"],"title":"【面试记录】","uri":"/posts/interview-record/"},{"categories":["面试记录"],"content":"介绍 position 有哪些布局以及它们的区别 （摘自 W3SCHOOL） 值 描述 static 默认。位置设置为 static 的元素，它始终会处于页面流给予的位置（static 元素会忽略任何 top、bottom、left 或 right 声明）。 relative 位置被设置为 relative 的元素，可将其移至相对于其正常位置的地方，因此 “left:20” 会将元素移至元素正常位置左边 20 个像素的位置。 absolute 位置设置为 absolute 的元素，可定位于相对于包含它的元素的指定坐标。此元素的位置可通过 “left”、“top”、“right” 以及 “bottom” 属性来规定。 fixed 位置被设置为 fixed 的元素，可定位于相对于浏览器窗口的指定坐标。此元素的位置可通过 “left”、“top”、“right” 以及\"bottom” 属性来规定。不论窗口滚动与否，元素都会留在那个位置。工作于 IE7（strict 模式）。 ","date":"2020-04-15","objectID":"/posts/interview-record/:3:3","tags":["面试"],"title":"【面试记录】","uri":"/posts/interview-record/"},{"categories":["面试记录"],"content":"JavaScript ","date":"2020-04-15","objectID":"/posts/interview-record/:4:0","tags":["面试"],"title":"【面试记录】","uri":"/posts/interview-record/"},{"categories":["面试记录"],"content":"Vue.js ","date":"2020-04-15","objectID":"/posts/interview-record/:5:0","tags":["面试"],"title":"【面试记录】","uri":"/posts/interview-record/"},{"categories":["面试记录"],"content":"对单页面（SPA）的理解 ","date":"2020-04-15","objectID":"/posts/interview-record/:5:1","tags":["面试"],"title":"【面试记录】","uri":"/posts/interview-record/"},{"categories":["面试记录"],"content":"单页面和多页面的区别 ","date":"2020-04-15","objectID":"/posts/interview-record/:5:2","tags":["面试"],"title":"【面试记录】","uri":"/posts/interview-record/"},{"categories":["面试记录"],"content":"什么时候用单页面，什么时候用多页面 ","date":"2020-04-15","objectID":"/posts/interview-record/:5:3","tags":["面试"],"title":"【面试记录】","uri":"/posts/interview-record/"},{"categories":["面试记录"],"content":"vue 中构造器的选项 computed 和 watch 的区别 简单来说就是 computed 是监听被多个值影响的一个值，watch 是监听一个值影响多个值的值，比如： watch:{ temp:function(newVal,oldVal){ if(newVal\u003e=26){ this.advise = advisearray[0] }else if(newVal\u003c26\u0026\u0026newVal\u003e0){ this.advise = advisearray[1] }else{ this.advise = advisearray[2] } } } temp 是在 data 中已经定义过的值，此处监听 temp 的变化，如果 temp 变化了则执行函数 computed:{ newPrice:function(){ return '￥'+this.price+'元' }, reverseNews:function(){ return this.newsList.reverse(); } } computed 监听的值不能在 data 中定义过，如果 computed 中监听的值的依赖值（即函数内调用过的值）发生了变化，则执行函数，该值也会发生变化 ","date":"2020-04-15","objectID":"/posts/interview-record/:5:4","tags":["面试"],"title":"【面试记录】","uri":"/posts/interview-record/"},{"categories":["面试记录"],"content":"v-show 和 v-if 的区别 ","date":"2020-04-15","objectID":"/posts/interview-record/:5:5","tags":["面试"],"title":"【面试记录】","uri":"/posts/interview-record/"},{"categories":["面试记录"],"content":"React ","date":"2020-04-15","objectID":"/posts/interview-record/:6:0","tags":["面试"],"title":"【面试记录】","uri":"/posts/interview-record/"},{"categories":["面试记录"],"content":"MongoDB ","date":"2020-04-15","objectID":"/posts/interview-record/:7:0","tags":["面试"],"title":"【面试记录】","uri":"/posts/interview-record/"},{"categories":["面试记录"],"content":"Node.js ","date":"2020-04-15","objectID":"/posts/interview-record/:8:0","tags":["面试"],"title":"【面试记录】","uri":"/posts/interview-record/"},{"categories":["面试记录"],"content":"模块系统的文件查找机制 st=\u003estart: 开始 cond1=\u003econdition: 不在文件模块缓存区中? cond2=\u003econdition: 是否原生模块? cond3=\u003econdition: 是否在原生模块缓存区中 e=\u003eend: 返回exports op1=\u003eoperation: 查找文件模块 st-\u003econd1 op2=\u003eoperation: 加载原生模块 op3=\u003eoperation: 缓存原生模块 op4=\u003eoperation: 根据扩展名载入文件模块 op5=\u003eoperation: 缓存文件模块 cond1(no)-\u003ee cond1(yes)-\u003econd2 cond2(yes)-\u003econd3 cond2(no)-\u003eop1 cond3(yes)-\u003ee cond3(no)-\u003eop2 op2-\u003eop3 op3-\u003ee op1-\u003eop4 op4-\u003eop5 op5-\u003ee ","date":"2020-04-15","objectID":"/posts/interview-record/:8:1","tags":["面试"],"title":"【面试记录】","uri":"/posts/interview-record/"},{"categories":["面试记录"],"content":"Linux ","date":"2020-04-15","objectID":"/posts/interview-record/:9:0","tags":["面试"],"title":"【面试记录】","uri":"/posts/interview-record/"},{"categories":["面试记录"],"content":"其他 ","date":"2020-04-15","objectID":"/posts/interview-record/:10:0","tags":["面试"],"title":"【面试记录】","uri":"/posts/interview-record/"},{"categories":["面试记录"],"content":"遇到过印象深刻的 bug，是怎么解决的 ","date":"2020-04-15","objectID":"/posts/interview-record/:10:1","tags":["面试"],"title":"【面试记录】","uri":"/posts/interview-record/"},{"categories":["学习记录"],"content":"JavaScript 中的数组的 sort 函数使用示例 假如数组一开始是这样的 items: [23, 23, 11, 2, 41, 67, 23, 23231]; 使用完 sort 后 sortitems:function(){ return this.items.sort() } 结果 显然可以看出它的排序结果是一个一个位的数字来排的，从第一位（左边第一位）开始排，为了让它能够实现我们想要的效果，可以添加一个这样的函数： function sortNumber(a, b) { return a - b; } 然后在使用 sort 时，把函数名放在 sort 函数的调用里，即 sortitems:function(){ return this.items.sort(sortNumber) } 就可以得到想要的结果了 ","date":"2020-04-14","objectID":"/posts/js-sort/:0:0","tags":["JavaScript","Array","sort"],"title":"【学习记录】JavaScript中数组的sort函数","uri":"/posts/js-sort/"},{"categories":["课程记录"],"content":"希望学完这些课，对 vue 的理解能更加深入，开发也能更得心应手 这篇博客，记录一些 vue 的知识点和课上用到过的插件 ","date":"2020-04-14","objectID":"/posts/jspang-basic-vue/:0:0","tags":["vue"],"title":"【技术胖】vue2.X","uri":"/posts/jspang-basic-vue/"},{"categories":["课程记录"],"content":"vue 基础 ","date":"2020-04-14","objectID":"/posts/jspang-basic-vue/:1:0","tags":["vue"],"title":"【技术胖】vue2.X","uri":"/posts/jspang-basic-vue/"},{"categories":["课程记录"],"content":"插件 live-server 这是一个快速服务器搭建的插件 安装 npm install live-server -g 启动 直接在要启动的项目路径下输入 live-server 端口在 8080 ","date":"2020-04-14","objectID":"/posts/jspang-basic-vue/:1:1","tags":["vue"],"title":"【技术胖】vue2.X","uri":"/posts/jspang-basic-vue/"},{"categories":["课程记录"],"content":"方法 对象形式的数组怎么进行排序 例如对象数组是这样的 students: [ { name: \"jspang\", age: 32 }, { name: \"Panda\", age: 30 }, { name: \"PanPaN\", age: 21 }, { name: \"King\", age: 45 }, ]; 数组对象方法排序: function sortByKey(array, key) { return array.sort(function (a, b) { var x = a[key]; var y = b[key]; return x \u003c y ? -1 : x \u003e y ? 1 : 0; }); } 用大括号赋值的弊端 用{{message}}赋值的弊端是，如果 JavaScript 没有正确引用出 vue.js 文件，那么网页上就会直接显示“{{message}}”，或者网速慢的时候也会这样， 可以用 v-text 来消除这个弊端，如果 message 里有 html 标签需要转译，就用 v-html v-text 和 v-html 果 message 里有 html 标签需要转译，就用 v-html，但是尽量少用，因为会引起 xss 攻击 多选框绑定数组 \u003cinput type=\"checkbox\" id=\"jspang\" value=\"jspang\" v-model=\"web_names\" /\u003e \u003clabel for=\"jspang\"\u003ejspang\u003c/label\u003e \u003cinput type=\"checkbox\" id=\"panda\" value=\"panda\" v-model=\"web_names\" /\u003e \u003clabel for=\"panda\"\u003epanda\u003c/label\u003e \u003cinput type=\"checkbox\" id=\"panpan\" value=\"panpan\" v-model=\"web_names\" /\u003e \u003clabel for=\"panpan\"\u003epanpan\u003c/label\u003e \u003c!-- \u003cp v-for=\"(name,index) in web_names\" :key=\"index\"\u003e{{name}}\u003c/p\u003e --\u003e \u003cp\u003e{{web_names}}\u003c/p\u003e vue 不支持“-” 例如，要在 vue 的 html 页面上使用 font-size 时，我们用“fontSize”代替，因为 vue 不支持使用“-” 为什么非要用 Vue.set 因为如果在其他方法改变外部（构造器外面）引入的 data 中，在虚拟 DOM 的值里只用下标改变数组的值，则 vue 无法监听到，这是 JavaScript 的一种限制，所以要用 Vue.set 例如： 外部引入的 data var outData = { count: 1, // goods:'car' arr: [\"aaa\", \"bbb\", \"ccc\"], }; 直接改变时 function add() { app.arr[1] = \"ddd\"; } 不能得到想要的结果 ","date":"2020-04-14","objectID":"/posts/jspang-basic-vue/:1:2","tags":["vue"],"title":"【技术胖】vue2.X","uri":"/posts/jspang-basic-vue/"},{"categories":["课程记录"],"content":"原生与 mixins 谁先执行 同一个生命周期方法，一般是构造器里的混入（即 mixins）先执行，再执行原生的，全局的混入比构造器里的混入更先执行 ","date":"2020-04-14","objectID":"/posts/jspang-basic-vue/:1:3","tags":["vue"],"title":"【技术胖】vue2.X","uri":"/posts/jspang-basic-vue/"},{"categories":["课程记录"],"content":"选项 mixins 与 extends 相同点 extends 与 mixins 一样，对于同一个生命周期方法，都比原生的更先执行，对于同一个名字的方法，不会执行 extends 和 mixins 的方法，而会只执行原生的 不同点 在构造器中的选项 extends 只能放一个对象（意思是只能有一个扩展），而 mixins 可以放一个数组 ","date":"2020-04-14","objectID":"/posts/jspang-basic-vue/:1:4","tags":["vue"],"title":"【技术胖】vue2.X","uri":"/posts/jspang-basic-vue/"},{"categories":["课程记录"],"content":"选项 delimiters 可以用 delimiters 修改插值形式，例如 delimiters: [\"${\", \"}\"]; 这样更改过后，插值就这样插了： ${num} ","date":"2020-04-14","objectID":"/posts/jspang-basic-vue/:1:5","tags":["vue"],"title":"【技术胖】vue2.X","uri":"/posts/jspang-basic-vue/"},{"categories":["课程记录"],"content":"vuerouter ","date":"2020-04-14","objectID":"/posts/jspang-basic-vue/:2:0","tags":["vue"],"title":"【技术胖】vue2.X","uri":"/posts/jspang-basic-vue/"},{"categories":["课程记录"],"content":"路由过渡动画 用 vue 的 transition 组件 ","date":"2020-04-14","objectID":"/posts/jspang-basic-vue/:2:1","tags":["vue"],"title":"【技术胖】vue2.X","uri":"/posts/jspang-basic-vue/"},{"categories":["课程记录"],"content":"404 页面的处理 在 router 的 index.js 中添加 { path: '*', component: error } ","date":"2020-04-14","objectID":"/posts/jspang-basic-vue/:2:2","tags":["vue"],"title":"【技术胖】vue2.X","uri":"/posts/jspang-basic-vue/"},{"categories":["课程记录"],"content":"vuex ","date":"2020-04-14","objectID":"/posts/jspang-basic-vue/:3:0","tags":["vue"],"title":"【技术胖】vue2.X","uri":"/posts/jspang-basic-vue/"},{"categories":["学习记录"],"content":"npm install XXX node_modules 下安装了，但是不会写入 package.json 里面 ","date":"2020-04-11","objectID":"/posts/npm-install-xxx/:1:0","tags":["npm"],"title":"【学习记录】关于npm install一些参数的问题","uri":"/posts/npm-install-xxx/"},{"categories":["学习记录"],"content":"npm install XXX -g 把包安装在全局了 ","date":"2020-04-11","objectID":"/posts/npm-install-xxx/:2:0","tags":["npm"],"title":"【学习记录】关于npm install一些参数的问题","uri":"/posts/npm-install-xxx/"},{"categories":["学习记录"],"content":"npm install XXX -save node_modules 下安装了，添加了依赖在 package.json 中的 dependencies 里面,即生产环境中要下载的包 ","date":"2020-04-11","objectID":"/posts/npm-install-xxx/:3:0","tags":["npm"],"title":"【学习记录】关于npm install一些参数的问题","uri":"/posts/npm-install-xxx/"},{"categories":["学习记录"],"content":"npm isstall XXX -save-dev node_modules 下安装了，添加了依赖在 package.json 中的 devDependencies 里面，开发模式中要用的包 ","date":"2020-04-11","objectID":"/posts/npm-install-xxx/:4:0","tags":["npm"],"title":"【学习记录】关于npm install一些参数的问题","uri":"/posts/npm-install-xxx/"},{"categories":["课程笔记"],"content":"Props 的生命周期函数 componentWillReceiveProps 该函数执行的话，要满足两个条件： 组件第一次存在于 dom 中，函数是不会执行的 如果已经存在于 dom 中，函数才会被执行 ","date":"2020-04-10","objectID":"/posts/jspang-react/:1:0","tags":["React","React16"],"title":"【技术胖】React16版基础","uri":"/posts/jspang-react/"},{"categories":["课程笔记"],"content":"获取远程数据的时刻 推荐在这个生命周期函数里获取远程数据，只加载一次的数据 componentDidMount(){ } ","date":"2020-04-10","objectID":"/posts/jspang-react/:2:0","tags":["React","React16"],"title":"【技术胖】React16版基础","uri":"/posts/jspang-react/"},{"categories":["课程笔记"],"content":"使用 EasyMock 模拟数据 网站没打开，是第 24 节课，等网站能打开再看这节课 ","date":"2020-04-10","objectID":"/posts/jspang-react/:3:0","tags":["React","React16"],"title":"【技术胖】React16版基础","uri":"/posts/jspang-react/"},{"categories":["课程笔记"],"content":"推荐的 React 动画库——react-transition-group 有三个基本库 Transition CSSTransition TransitionGroup ","date":"2020-04-10","objectID":"/posts/jspang-react/:4:0","tags":["React","React16"],"title":"【技术胖】React16版基础","uri":"/posts/jspang-react/"},{"categories":["课程记录"],"content":"去年看了这个视频，然后根据方法一步步做出了毕设，考研一年没有写过代码了，很多都忘了，现在为了重构毕设的项目，重新看了这个视频，vue 已经更新了，比如视频创建项目是用“vue init”，但是现在版本的 vue-cli 用的是“vue create”，于是为了跟上新技术，很多地方没有仿照视频一起做，而是看了官方文档再写的。这篇博客记录一下课程上提到的一些插件和便捷开发的方法。 ","date":"2020-04-08","objectID":"/posts/imooc-mongodb-vue-express-demo/:0:0","tags":["vue2.0","Node.js","MongoDB","Express"],"title":"【慕课网】Vue2.0+Node.js+MongoDB全栈打造商城系统","uri":"/posts/imooc-mongodb-vue-express-demo/"},{"categories":["课程记录"],"content":"express-generator 看 express 中文网 https://www.expressjs.com.cn/starter/generator.html 用 express-generator 新建一个 server 目录 express --view=pug server ","date":"2020-04-08","objectID":"/posts/imooc-mongodb-vue-express-demo/:1:0","tags":["vue2.0","Node.js","MongoDB","Express"],"title":"【慕课网】Vue2.0+Node.js+MongoDB全栈打造商城系统","uri":"/posts/imooc-mongodb-vue-express-demo/"},{"categories":["课程记录"],"content":"vue-lazyload 可以在www.npmjs.com上查找到vue-lazyload，根据文档的内容来实现图片懒加载 ","date":"2020-04-08","objectID":"/posts/imooc-mongodb-vue-express-demo/:2:0","tags":["vue2.0","Node.js","MongoDB","Express"],"title":"【慕课网】Vue2.0+Node.js+MongoDB全栈打造商城系统","uri":"/posts/imooc-mongodb-vue-express-demo/"},{"categories":["课程记录"],"content":"pm2 基于进程管理，可以实现当前电脑的负载均衡 ","date":"2020-04-08","objectID":"/posts/imooc-mongodb-vue-express-demo/:3:0","tags":["vue2.0","Node.js","MongoDB","Express"],"title":"【慕课网】Vue2.0+Node.js+MongoDB全栈打造商城系统","uri":"/posts/imooc-mongodb-vue-express-demo/"},{"categories":["课程记录"],"content":"mongoose 对 MongoDB 的封装 ","date":"2020-04-08","objectID":"/posts/imooc-mongodb-vue-express-demo/:4:0","tags":["vue2.0","Node.js","MongoDB","Express"],"title":"【慕课网】Vue2.0+Node.js+MongoDB全栈打造商城系统","uri":"/posts/imooc-mongodb-vue-express-demo/"},{"categories":["课程记录"],"content":"tips 用 MongoDB 创建表时，表名后面一定要加“s” ","date":"2020-04-08","objectID":"/posts/imooc-mongodb-vue-express-demo/:5:0","tags":["vue2.0","Node.js","MongoDB","Express"],"title":"【慕课网】Vue2.0+Node.js+MongoDB全栈打造商城系统","uri":"/posts/imooc-mongodb-vue-express-demo/"},{"categories":["bug解决记录"],"content":"问题描述 ","date":"2020-04-07","objectID":"/posts/vue-error1/:1:0","tags":["vue","组件"],"title":"【错误记录】子组件解决父组件传来的值需要进行改变的情况","uri":"/posts/vue-error1/"},{"categories":["bug解决记录"],"content":"父组件代码 \u003ctemplate\u003e \u003cdiv class=\"hello\"\u003e \u003cCounter :num=\"num\"\u003e\u003c/Counter\u003e \u003cp\u003e \u003cspan\u003eparant:{{ num }}\u003c/span\u003e \u003c/p\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import Counter from \"./Counter\"; export default { name: \"HelloWorld\", data() { return { num: 10, }; }, components: { Counter, }, }; \u003c/script\u003e \u003cstyle scoped\u003e\u003c/style\u003e ","date":"2020-04-07","objectID":"/posts/vue-error1/:1:1","tags":["vue","组件"],"title":"【错误记录】子组件解决父组件传来的值需要进行改变的情况","uri":"/posts/vue-error1/"},{"categories":["bug解决记录"],"content":"子组件代码 \u003ctemplate\u003e \u003cdiv\u003e \u003cbutton v-on:click=\"increment()\"\u003e+\u003c/button\u003e \u003cbutton v-on:click=\"decrement()\"\u003e-\u003c/button\u003e \u003cp\u003e \u003cspan\u003e{{ num }}\u003c/span\u003e \u003c/p\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { props: { num: Number, }, data() { return {}; }, methods: { increment() { this.num++; }, decrement() { this.num--; }, }, }; \u003c/script\u003e \u003cstyle\u003e\u003c/style\u003e ","date":"2020-04-07","objectID":"/posts/vue-error1/:1:2","tags":["vue","组件"],"title":"【错误记录】子组件解决父组件传来的值需要进行改变的情况","uri":"/posts/vue-error1/"},{"categories":["bug解决记录"],"content":"实现效果 但是当按下加号或减号时，控制台出现 warn vue.runtime.esm.js?2b0e:619 [Vue warn]: Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop's value. Prop being mutated: \"num\" found in ---\u003e \u003cCounter\u003e at src/components/Counter.vue \u003cHelloWorld\u003e at src/components/HelloWorld.vue \u003cApp\u003e at src/App.vue \u003cRoot\u003e ","date":"2020-04-07","objectID":"/posts/vue-error1/:1:3","tags":["vue","组件"],"title":"【错误记录】子组件解决父组件传来的值需要进行改变的情况","uri":"/posts/vue-error1/"},{"categories":["bug解决记录"],"content":"错误原因 这是因为在 vue2.0 中移除了组件的 props 的双向数据绑定功能，如果需要双向数据绑定需要自己来实现。子组件只能被动地接收父组件传递过来的数据，并在子组件内不能修改由父组件传递过来的 props 数据。 官方文档解释 prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来。这是为了防止子组件无意修改了父组件的状态——这会让应用的数据流难以理解。 我们可以利用$emit 功能实现子组件传递数据给父组件的功能，进而实现双向数据绑定。 ","date":"2020-04-07","objectID":"/posts/vue-error1/:1:4","tags":["vue","组件"],"title":"【错误记录】子组件解决父组件传来的值需要进行改变的情况","uri":"/posts/vue-error1/"},{"categories":["bug解决记录"],"content":"解决方法 ","date":"2020-04-07","objectID":"/posts/vue-error1/:2:0","tags":["vue","组件"],"title":"【错误记录】子组件解决父组件传来的值需要进行改变的情况","uri":"/posts/vue-error1/"},{"categories":["bug解决记录"],"content":"父组件代码 \u003ctemplate\u003e \u003cdiv class=\"hello\"\u003e \u003cCounter :num=\"num\" v-on:incre=\"increment\" v-on:decre=\"decrement\"\u003e\u003c/Counter\u003e \u003cp\u003e \u003cspan\u003eparant:{{ num }}\u003c/span\u003e \u003c/p\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import Counter from \"./Counter\"; export default { name: \"HelloWorld\", data() { return { num: 10, }; }, components: { Counter, }, methods: { increment() { this.num++; }, decrement() { this.num--; }, }, }; \u003c/script\u003e \u003cstyle scoped\u003e\u003c/style\u003e ","date":"2020-04-07","objectID":"/posts/vue-error1/:2:1","tags":["vue","组件"],"title":"【错误记录】子组件解决父组件传来的值需要进行改变的情况","uri":"/posts/vue-error1/"},{"categories":["bug解决记录"],"content":"子组件代码 \u003ctemplate\u003e \u003cdiv\u003e \u003cbutton v-on:click=\"increment()\"\u003e+\u003c/button\u003e \u003cbutton v-on:click=\"decrement()\"\u003e-\u003c/button\u003e \u003cp\u003e \u003cspan\u003e{{ num }}\u003c/span\u003e \u003c/p\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { props: { num: Number, }, data() { return {}; }, methods: { increment() { this.$emit(\"incre\"); }, decrement() { this.$emit(\"decre\"); }, }, }; \u003c/script\u003e \u003cstyle\u003e\u003c/style\u003e ","date":"2020-04-07","objectID":"/posts/vue-error1/:2:2","tags":["vue","组件"],"title":"【错误记录】子组件解决父组件传来的值需要进行改变的情况","uri":"/posts/vue-error1/"},{"categories":["bug解决记录"],"content":"问题描述 “vue : 无法加载文件 C:\\Users\\xxx\\AppData\\Roaming\\npm\\vue.ps1，因为在此系统上禁止运行脚本。” ","date":"2020-04-07","objectID":"/posts/vue-error/:1:0","tags":["vue","vue-cli"],"title":"【错误记录】命令行上无法执行vue命令","uri":"/posts/vue-error/"},{"categories":["bug解决记录"],"content":"问题解决 以管理员身份运行 Powershell 执行 get-ExecutionPolicy 回复 Restricted，说明现在状态是禁止的 执行 set-ExecutionPolicy RemoteSigned 如有必要，选择 Y Notes: 一定要用管理员身份运行 Powershell，而不是 cmd 该项适用于其他用 npm 全局下载的命令无法直接执行的问题，比如：“hexo”，在这之前我一直用的是“npx hexo ……”开头的 ","date":"2020-04-07","objectID":"/posts/vue-error/:2:0","tags":["vue","vue-cli"],"title":"【错误记录】命令行上无法执行vue命令","uri":"/posts/vue-error/"},{"categories":["学习记录"],"content":"这是在看一个实战课的时候，老师讲到的一个知识点，我觉得挺有意思的，虽然很简单，但是让我稍微了解了一下框架背后的故事，所以记录一下~ 源码如下 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput type=\"text\" id=\"userName\" /\u003e \u003cbr /\u003e \u003cspan id=\"uName\"\u003e\u003c/span\u003e \u003cscript\u003e var obj = { pwd: \"123456\", }; Object.defineProperty(obj, \"myName\", { get: function () { console.log(\"get init\"); }, set: function (val) { console.log(\"set init\"); document.getElementById(\"uName\").innerText = val; document.getElementById(\"userName\").value = val; }, }); document.getElementById(\"userName\").addEventListener(\"keyup\", function (event) { obj.myName = event.target.value; }); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-04-06","objectID":"/posts/vue-databind-source/:0:0","tags":["vue","数据绑定"],"title":"【学习记录】初步探索vue数据双向绑定原理","uri":"/posts/vue-databind-source/"},{"categories":["课程记录"],"content":"讲师：Dell 课程：https://coding.imooc.com/class/chapter/316.html#Anchor ","date":"2020-04-01","objectID":"/posts/imooc-webpack4/:0:0","tags":["webpack","webpack4.0"],"title":"【慕课网】从基础到实战 手把手带你掌握新版Webpack4.0","uri":"/posts/imooc-webpack4/"},{"categories":["课程记录"],"content":"webpack 的两种安装方式 全局安装 npm install webpack webpack-cli -g 尽量不要全局安装，因为有时不同的项目是用不同版本的 webpack 打包的 卸载 webpack npm uninstall webpack webpack-cli -g 在命令行输入 webpack -v 检验是否安装成功 在项目内安装 npm install webpack webpack-cli -D 或 npm install webpack webpack-cli --save-dev “–save-dev\"等价于”-D\" 在命令行输入 npx webpack -v 检验是否安装成功，使用 npx 是在当前目录下找命令 安装固定版本号的 webpack npm install webpack@XX.XX.XX webpack-cli -D 安装前可以输入 npm info webpack 检验该版本是否存在 ","date":"2020-04-01","objectID":"/posts/imooc-webpack4/:1:0","tags":["webpack","webpack4.0"],"title":"【慕课网】从基础到实战 手把手带你掌握新版Webpack4.0","uri":"/posts/imooc-webpack4/"},{"categories":["课程记录"],"content":"更改 webpack 的配置文件 webpack 的默认配置文件是 webpack.config.js，如果要将它改成 webpackconfig.js，需要执行下条命令 npx webpack --config webpackconfig.js ","date":"2020-04-01","objectID":"/posts/imooc-webpack4/:2:0","tags":["webpack","webpack4.0"],"title":"【慕课网】从基础到实战 手把手带你掌握新版Webpack4.0","uri":"/posts/imooc-webpack4/"},{"categories":["课程记录"],"content":"模块导出/引入方式 模块导出 //ES Moudule 模块导出方式 export default Header; //CommonJS 模块导出 module.exports = Header; 模块引入 //ESMoudule 模块引入方式 import Header from ('./header.js'); //CommonJS 模块引入方式 var Header = require('./header.js'); ","date":"2020-04-01","objectID":"/posts/imooc-webpack4/:3:0","tags":["webpack","webpack4.0"],"title":"【慕课网】从基础到实战 手把手带你掌握新版Webpack4.0","uri":"/posts/imooc-webpack4/"},{"categories":["课程记录"],"content":"用 npm script 简化打包代码 添加了配置文件 webpack.config.js 后，可以用 npx webpack 运行 webpack 打包文件，我们尝试在项目的 package.json 的 scripts 条目中添加一条： \"scripts\": { \"bundle\":\"webpack\" }, 这样就可以用 npm run bundle 来执行文件打包了 ","date":"2020-04-01","objectID":"/posts/imooc-webpack4/:4:0","tags":["webpack","webpack4.0"],"title":"【慕课网】从基础到实战 手把手带你掌握新版Webpack4.0","uri":"/posts/imooc-webpack4/"},{"categories":["课程记录"],"content":"loader 的执行顺序 当一个类型使用多个 loader 时，loader 的执行顺序是从下到上、从右到左的，例如： { test: /\\.scss$/, use: ['style-loader','css-loader','sass-loader'] } 首先执行 sass-loader 对 sass 文件进行翻译,翻译成 css 代码给到 css-loader 处理，处理好再给 style-loader 挂载到页面上 ","date":"2020-04-01","objectID":"/posts/imooc-webpack4/:5:0","tags":["webpack","webpack4.0"],"title":"【慕课网】从基础到实战 手把手带你掌握新版Webpack4.0","uri":"/posts/imooc-webpack4/"},{"categories":["课程记录"],"content":"postcss-loader 自动添加厂商前缀 先安装 postcss-loader npm i -D postcss-loader 再安装 autoprefixer 插件 npm install autoprefixer -D 添加 postcss-loader 配置文件 postcss.config.js module.exports = { plugins: [require(\"autoprefixer\")], }; 再启动打包 ","date":"2020-04-01","objectID":"/posts/imooc-webpack4/:6:0","tags":["webpack","webpack4.0"],"title":"【慕课网】从基础到实战 手把手带你掌握新版Webpack4.0","uri":"/posts/imooc-webpack4/"},{"categories":["课程记录"],"content":"css-loader 的 options 相关值 importLoaders css-loader 中的 importLoaders，表示通过 import 引入的类型文件，也要其他 loader 打包一下，例如 loader:'css-loader', options:{ importLoaders:2 } 表示要用下面的两个 loader 先打包再用 css-loader 打包 modules 当设置为 true 时，表示 css 可模块化,在文件中引入 css 文件时，可以这样引入 import style from './index.scss'; 使用 index.scss 中的类名设置样式时，可以这样使用 img.classList.add(style.avatar); ","date":"2020-04-01","objectID":"/posts/imooc-webpack4/:7:0","tags":["webpack","webpack4.0"],"title":"【慕课网】从基础到实战 手把手带你掌握新版Webpack4.0","uri":"/posts/imooc-webpack4/"},{"categories":["课程记录"],"content":"使用 webpack 打包字体文件 对于字体文件，即后缀为 eot、ttf、svg 的文件，打包时用 file-loader ","date":"2020-04-01","objectID":"/posts/imooc-webpack4/:8:0","tags":["webpack","webpack4.0"],"title":"【慕课网】从基础到实战 手把手带你掌握新版Webpack4.0","uri":"/posts/imooc-webpack4/"},{"categories":["课程记录"],"content":"webpack 插件——plugin plugin 可以在 webpack 运行到某个时刻的时候，帮你做一些事情，类似 vue 的生命周期函数 html-webpack-plugin 会在打包结束后自动生成一个 html 文件，并把打包生成的 js 自动引入到这个 html 文件中，但是这个 html 文件并没有相关标签，如果要有相关标签的话，要进行配置，如下： 先安装 npm install html-webpack-plugin 然后在 webpack.config.js 里面进行配置 const HtmlWebpackPlugin = require(\"html-webpack-plugin\"); plugins: [ new HtmlWebpackPlugin({ template: \"src/index.html\", }), ]; template 的属性值是模板的路径，模板代码如下： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e \u003ctitle\u003ehtml模板\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"root\"\u003e\u003c/div\u003e \u003c/body\u003e \u003c/html\u003e clean-webpack-plugin 当重新打包之前，可以把上一次打包的目录都删除，在 webpack.config.js 里面的配置如下 const {CleanWebpackPlugin} = require('clean-webpack-plugin'); plugins:[ new CleanWebpackPlugin() ], ","date":"2020-04-01","objectID":"/posts/imooc-webpack4/:9:0","tags":["webpack","webpack4.0"],"title":"【慕课网】从基础到实战 手把手带你掌握新版Webpack4.0","uri":"/posts/imooc-webpack4/"},{"categories":["课程记录"],"content":"output 配置项——publicPath 如果静态资源放在 cdn 上，可以设置该配置 ","date":"2020-04-01","objectID":"/posts/imooc-webpack4/:10:0","tags":["webpack","webpack4.0"],"title":"【慕课网】从基础到实战 手把手带你掌握新版Webpack4.0","uri":"/posts/imooc-webpack4/"},{"categories":["课程记录"],"content":"SourceMap 的配置 在 mode 为 development 即开发者模式下，SourceMap 已经配置好了 SourceMap 是一个映射关系，它知道打包出错的的文件对应未打包的文件的错误位置 将 webpack.config.js 中添加一个属性如下： mode: 'development', devtool:'source-map', 这样打包后的代码出错，在控制台可以直接进入到源文件的错误位置 ","date":"2020-04-01","objectID":"/posts/imooc-webpack4/:11:0","tags":["webpack","webpack4.0"],"title":"【慕课网】从基础到实战 手把手带你掌握新版Webpack4.0","uri":"/posts/imooc-webpack4/"},{"categories":["课程记录"],"content":"讲师：Jokcy 课程：https://www.imooc.com/learn/935 ","date":"2020-03-31","objectID":"/posts/imooc-webpack-vue/:0:0","tags":["webpack","vue","todo"],"title":"【慕课网】Vue+Webpack打造todo应用","uri":"/posts/imooc-webpack-vue/"},{"categories":["课程记录"],"content":"课程介绍 ","date":"2020-03-31","objectID":"/posts/imooc-webpack-vue/:1:0","tags":["webpack","vue","todo"],"title":"【慕课网】Vue+Webpack打造todo应用","uri":"/posts/imooc-webpack-vue/"},{"categories":["课程记录"],"content":"课程目标 配置开发时前端工程 实现一个简单的 TODO 应用 优化配置达到上线标准 ","date":"2020-03-31","objectID":"/posts/imooc-webpack-vue/:1:1","tags":["webpack","vue","todo"],"title":"【慕课网】Vue+Webpack打造todo应用","uri":"/posts/imooc-webpack-vue/"},{"categories":["课程记录"],"content":"步骤 ","date":"2020-03-31","objectID":"/posts/imooc-webpack-vue/:2:0","tags":["webpack","vue","todo"],"title":"【慕课网】Vue+Webpack打造todo应用","uri":"/posts/imooc-webpack-vue/"},{"categories":["课程记录"],"content":"1. 创建一个新项目 ","date":"2020-03-31","objectID":"/posts/imooc-webpack-vue/:2:1","tags":["webpack","vue","todo"],"title":"【慕课网】Vue+Webpack打造todo应用","uri":"/posts/imooc-webpack-vue/"},{"categories":["课程记录"],"content":"2. 在命令行输入 npm init 生成 package.json 文件， ","date":"2020-03-31","objectID":"/posts/imooc-webpack-vue/:2:2","tags":["webpack","vue","todo"],"title":"【慕课网】Vue+Webpack打造todo应用","uri":"/posts/imooc-webpack-vue/"},{"categories":["课程记录"],"content":"3. 然后安装 webpack,vue,vue-loader，在命令行输入 npm i webpack vue vue-loader 产生 WARN 警告一 Legacy versions of mkdirp are no longer supported. Please update to mkdirp 1.x. (Note that the API surface has changed to use Promises in 1.x.) mkdirp 旧版本已经移除，要更新到新版本，在命令行输入命令更新： npm install -g mkdirp 警告二 npm WARN vue-loader@15.9.1 requires a peer of css-loader@* but none is installed. You must install peer dependencies yourself. vue-loader 需要 css-loader 作为它的 peer，故执行下条命令，安装 css-loader npm install css-loader 警告三 npm WARN webpack-vue@1.0.0 No description npm WARN webpack-vue@1.0.0 No repository field. npm 中缺少相关信息，不要紧的 警告四 npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.12 (node_modules\\fsevents): npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.12: wanted {\"os\":\"darwin\",\"arch\":\"any\"} (current: {\"os\":\"win32\",\"arch\":\"x64\"}) ","date":"2020-03-31","objectID":"/posts/imooc-webpack-vue/:2:3","tags":["webpack","vue","todo"],"title":"【慕课网】Vue+Webpack打造todo应用","uri":"/posts/imooc-webpack-vue/"},{"categories":["课程记录"],"content":"4. 新建 src/app.Vue 文件 app.vue \u003ctemplate\u003e \u003cdiv id=\"text\"\u003e{{ text }}\u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { data() { return { text: \"abc\", }; }, }; \u003c/script\u003e \u003cstyle\u003e #text { color: red; } \u003c/style\u003e ","date":"2020-03-31","objectID":"/posts/imooc-webpack-vue/:2:4","tags":["webpack","vue","todo"],"title":"【慕课网】Vue+Webpack打造todo应用","uri":"/posts/imooc-webpack-vue/"},{"categories":["课程记录"],"content":"5. 在根目录新建 webpack.config.js 文件 web.config.js const path = require(\"path\"); module.exports = { entry: path.join(__dirname, \"src/index.js\"), output: { filename: \"bundle.js\", path: path.join(__dirname, \"dist\"), }, }; 这里的_dirname 表示的是根目录 ","date":"2020-03-31","objectID":"/posts/imooc-webpack-vue/:2:5","tags":["webpack","vue","todo"],"title":"【慕课网】Vue+Webpack打造todo应用","uri":"/posts/imooc-webpack-vue/"},{"categories":["课程记录"],"content":"6. 在 src 目录下创建 index.js 文件作为入口文件 index.js import Vue from \"vue\"; import App from \"./app.vue\"; const root = document.createElement(\"div\"); document.body.appendChild(root); new Vue({ render: (h) =\u003e h(App), }).$mount(root); ","date":"2020-03-31","objectID":"/posts/imooc-webpack-vue/:2:6","tags":["webpack","vue","todo"],"title":"【慕课网】Vue+Webpack打造todo应用","uri":"/posts/imooc-webpack-vue/"},{"categories":["课程记录"],"content":"7. 在 package.json 文件的 scripts 属性下新增一个条目 \"build\": \"webpack --config webpack.config.js\" 使得在命令行打开 webpack 时打开的是 webpack.config.js 文件而不是全局 webpack ","date":"2020-03-31","objectID":"/posts/imooc-webpack-vue/:2:7","tags":["webpack","vue","todo"],"title":"【慕课网】Vue+Webpack打造todo应用","uri":"/posts/imooc-webpack-vue/"},{"categories":["课程记录"],"content":"8. 在命令行输入跑一下项目 npm run build 遇到错误 You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders 需要配置 loader，在 webpack.config.js 的 modul.exports 中添加 module: { rules: [ { test: /.vue$/, loader: \"vue-loader\", }, ]; } 重新运行上一条命令以启动项目，结果出现报错 WARNING in configuration The 'mode' option has not been set, webpack will fallback to 'production' for this value. Set 'mode' option to 'development' or 'production' to enable defaults for each environment. You can also set it to 'none' to disable any default behavior. Learn more: https://webpack.js.org/configuration/mode/ ERROR in ./src/app.vue Module Error (from ./node_modules/vue-loader/lib/index.js): [vue-loader] vue-template-compiler must be installed as a peer dependency, or a compatible compiler implementation must be passed via options. @ ./src/index.js 2:0-27 8:18-21 ERROR in ./src/app.vue Module Error (from ./node_modules/vue-loader/lib/index.js): vue-loader was used without the corresponding plugin. Make sure to include VueLoaderPlugin in your webpack config. @ ./src/index.js 2:0-27 8:18-21 ERROR in ./src/app.vue Module build failed (from ./node_modules/vue-loader/lib/index.js): TypeError: Cannot read property 'parseComponent' of undefined at parse (D:\\MyCode\\IMOOC\\webpack-vue\\node_modules\\@vue\\component-compiler-utils\\dist\\parse.js:14:23) at Object.module.exports (D:\\MyCode\\IMOOC\\webpack-vue\\node_modules\\vue-loader\\lib\\index.js:67:22) @ ./src/index.js 2:0-27 8:18-21 解决方法： 安装 vue-template-compiler npm install vue-template-compiler 引入 VueLoaderPlugin 在 webpack.config.js 开头引入 const { VueLoaderPlugin } = require(\"vue-loader\"); module.exports 中增加 plugins:[new VueLoaderPlugin()], 引入 css-loader {test:/\\.css$/,use:'css-loader'} 最终的 webpack.config.js 代码如下： const path = require(\"path\"); const { VueLoaderPlugin } = require(\"vue-loader\"); module.exports = { entry: path.join(__dirname, \"src/index.js\"), output: { filename: \"bundle.js\", path: path.join(__dirname, \"dist\"), }, module: { rules: [ { test: /.vue$/, loader: \"vue-loader\", }, { test: /\\.css$/, use: \"css-loader\", }, ], }, plugins: [new VueLoaderPlugin()], //开发环境 mode: \"development\", }; ","date":"2020-03-31","objectID":"/posts/imooc-webpack-vue/:2:8","tags":["webpack","vue","todo"],"title":"【慕课网】Vue+Webpack打造todo应用","uri":"/posts/imooc-webpack-vue/"},{"categories":["课程记录"],"content":"根据 webpack 配置安装 npm i style-loader url-loader file-loader ","date":"2020-03-31","objectID":"/posts/imooc-webpack-vue/:2:9","tags":["webpack","vue","todo"],"title":"【慕课网】Vue+Webpack打造todo应用","uri":"/posts/imooc-webpack-vue/"},{"categories":["学习记录"],"content":"px 与 em 的转换 在大多数浏览器下的默认换算是 1em==16px.可以参考 http://riddle.pl/emcalc/ ","date":"2020-03-31","objectID":"/posts/log-css/:1:0","tags":["CSS"],"title":"【学习记录】CSS","uri":"/posts/log-css/"},{"categories":["学习记录"],"content":"选择器优先级计算 一个选择器的优先级可以说是由四个部分相加(分量)，可以认为是个十百千——四位数的四个位数： 千位：如果声明在 style 的属性（内联样式）则该位得一分。这样的生命没有选择器，所以得分总是 1000。 百位：选择器中包含 ID 选择器则该位得一分。 十位：选择器中包含类选择器、属性选择器或者伪类则该位得一分。 个位：选择器中包含元素、伪元素选择器则该位得一分。 例如： 选择器 千位 百位 十位 个位 优先级 h1 0 0 0 1 0001 h1 + p::first-letter 0 0 0 3 0003 li \u003e a[href*=“en-US”] \u003e .inline-warning 0 0 2 2 0022 #identifier 0 1 0 0 0100 内联样式 1 0 0 0 1000 但是“!important”可以覆盖掉所有优先级的计算 ","date":"2020-03-31","objectID":"/posts/log-css/:2:0","tags":["CSS"],"title":"【学习记录】CSS","uri":"/posts/log-css/"},{"categories":["学习记录"],"content":"SVG 跨浏览器支持 ","date":"2020-03-30","objectID":"/posts/cross-browser/:1:0","tags":["跨浏览器","前端"],"title":"【学习记录】一些跨浏览器的方法","uri":"/posts/cross-browser/"},{"categories":["学习记录"],"content":"方法一 在 img 元素内使用“src”属性引用 PNG 或 JPG 等低版本浏览器支持的类型，并且用“srcset”属性引用 SVG 类型，这种情况，支持的浏览器将加载 SVG，较旧的浏览器将加载 PNG 等。例如， \u003cimg src=\"equilateral.png\" alt=\"triangle with equal sides\" srcset=\"equilateral.svg\" /\u003e ","date":"2020-03-30","objectID":"/posts/cross-browser/:1:1","tags":["跨浏览器","前端"],"title":"【学习记录】一些跨浏览器的方法","uri":"/posts/cross-browser/"},{"categories":["学习记录"],"content":"方法二 将 SVG 作为 CSS 背景图像，如下,旧浏览器会坚持 PNG 等，支持 SVG 的浏览器将加载 SVG background: url(\"fallback.png\") no-repeat center; background-image: url(\"image.svg\"); background-size: contain; ","date":"2020-03-30","objectID":"/posts/cross-browser/:1:2","tags":["跨浏览器","前端"],"title":"【学习记录】一些跨浏览器的方法","uri":"/posts/cross-browser/"},{"categories":["学习记录"],"content":" SEO：Search Engine Optimization，汉译为搜索引擎优化。是一种方式：利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名。目的是让其在行业内占据领先地位，获得品牌收益。很大程度上是网站经营者的一种商业行为，将自己或自己公司的排名前移。——————来源：百度百科 光栅图：也叫做位图、点阵图、像素图，简单的说，就是最小单位由像素构成的图，只有点的信息，缩放时会失真。每个像素有自己的颜色，类似电脑里的图片都是像素图，你把它放很大就会看到点变成小色块了。 ","date":"2020-03-29","objectID":"/posts/log-iknow/:0:0","tags":["缩写","知识点"],"title":"【学习记录】“文盲”时刻","uri":"/posts/log-iknow/"},{"categories":["学习记录"],"content":"实体引用 原义字符 等价字符引用 \u003c \u0026lt; ‘\u003e’ \u0026gt; \" \u0026quot; ' \u0026apos; \u0026 \u0026amp; ","date":"2020-03-25","objectID":"/posts/log-html/:1:0","tags":["HTML"],"title":"【学习记录】HTML","uri":"/posts/log-html/"},{"categories":["学习记录"],"content":"指定文档字符编码 utf-8 一个通用的字符集，它包含了任何人类语言中的大部分的字符。一些浏览器会自动修正错误的编码，但是应该要手动为页面设置编码为 utf-8，如下： \u003cmeta charset=\"utf-8\" /\u003e 来避免在其他浏览器中可能出现的潜在问题。 ","date":"2020-03-25","objectID":"/posts/log-html/:2:0","tags":["HTML"],"title":"【学习记录】HTML","uri":"/posts/log-html/"},{"categories":["学习记录"],"content":"使用标题 最好只对每个页面使用一次\u003ch1\u003e，这是顶级标题，所有其他标题位于层次结构中的下方。 确保在层次结构中以正确的顺序使用标题。 在可用的六个标题级别中，每页最好使用不超过三个。 ","date":"2020-03-25","objectID":"/posts/log-html/:3:0","tags":["HTML"],"title":"【学习记录】HTML","uri":"/posts/log-html/"},{"categories":["学习记录"],"content":"屏幕阅读器 screen reader，使页面结构化，也能让屏幕阅读器更好识别内容的不同元素。 ","date":"2020-03-25","objectID":"/posts/log-html/:4:0","tags":["HTML"],"title":"【学习记录】HTML","uri":"/posts/log-html/"},{"categories":["学习记录"],"content":"超链接的 download 属性 当链接到要下载的资源而不是在浏览器中打开时，可以使用 download 属性来提供一个默认的保存文件名（此属性只适用于同源 URL），如下是一个下载链接到 Firefox 的 Windows 最新版本的示例： \u003ca href=\"https://download.mozilla.org/?product=firefox-latest-ssl\u0026os=win64\u0026lang=en-US\" download=\"firefox-latest-64bit-installer.exe\" \u003e Download Latest Firefox for Windows (64-bit) (English, US) \u003c/a\u003e 效果如下： Download Latest Firefox for Windows (64-bit) (English, US) ","date":"2020-03-25","objectID":"/posts/log-html/:5:0","tags":["HTML"],"title":"【学习记录】HTML","uri":"/posts/log-html/"},{"categories":["学习记录"],"content":"\u003ctime\u003e元素 HTML 支持将时间和日期标记为可供机器识别的格式的 \u003ctime\u003e 元素。例如： \u003c!-- 标准简单日期 --\u003e \u003ctime datetime=\"2016-01-20\"\u003e20 January 2016\u003c/time\u003e \u003c!-- 只包含年份和月份--\u003e \u003ctime datetime=\"2016-01\"\u003eJanuary 2016\u003c/time\u003e \u003c!-- 只包含月份和日期 --\u003e \u003ctime datetime=\"01-20\"\u003e20 January\u003c/time\u003e \u003c!-- 只包含时间，小时和分钟数 --\u003e \u003ctime datetime=\"19:30\"\u003e19:30\u003c/time\u003e \u003c!-- 还可包含秒和毫秒 --\u003e \u003ctime datetime=\"19:30:01.856\"\u003e19:30:01.856\u003c/time\u003e \u003c!-- 日期和时间 --\u003e \u003ctime datetime=\"2016-01-20T19:30\"\u003e7.30pm, 20 January 2016\u003c/time\u003e \u003c!-- 含有时区偏移值的日期时间 --\u003e \u003ctime datetime=\"2016-01-20T19:30+01:00\"\u003e7.30pm, 20 January 2016 is 8.30pm in France\u003c/time\u003e \u003c!-- 调用特定的周 --\u003e \u003ctime datetime=\"2016-W04\"\u003eThe fourth week of 2016\u003c/time\u003e ","date":"2020-03-25","objectID":"/posts/log-html/:6:0","tags":["HTML"],"title":"【学习记录】HTML","uri":"/posts/log-html/"},{"categories":["学习记录"],"content":"图片版权 在得到授权之前，永远不要把 img 的 src 属性指向其他人网站上的图片 ","date":"2020-03-25","objectID":"/posts/log-html/:7:0","tags":["HTML"],"title":"【学习记录】HTML","uri":"/posts/log-html/"},{"categories":["学习记录"],"content":"视频/音频的容器格式 视频和音频都有不同的格式，如下： WebM 容器通常包括了 Ogg Vorbis 音频和 VP8/VP9 视频。主要在 FIrefox 和 Chrome 当中支持。 MP4 容器通常包括 AAC 以及 MP3 音频和 H.264 视频。主要在 Internet Explorer 和 Safari 当中支持。 老式的 Ogg 容器往往支持 Ogg Vorbis 音频和 Ogg Theora 视频。主要在 Firefox 和 Chrome 当中支持，不过这个容器已经被更强大的 WebM 容器所取代。 音频播放器将会直接播放音频文件，例如 MP3 和 Ogg 文件。这些不需要容器 详见音视频编码兼容表","date":"2020-03-25","objectID":"/posts/log-html/:8:0","tags":["HTML"],"title":"【学习记录】HTML","uri":"/posts/log-html/"},{"categories":["学习记录"],"content":"生成按钮 生成 submit 按钮有两种方法，一是用 input： \u003cinput type=\"submit\" /\u003e 另一种是用 button： \u003cbutton type=\"submit\"\u003e\u003c/button\u003e \u003cbutton\u003e元素的主要优点是， \u003cinput\u003e元素只允许纯文本作为其标签，而\u003cbutton\u003e元素允许完整的 HTML 内容，允许更复杂、更有创意的按钮文本。 ","date":"2020-03-25","objectID":"/posts/log-html/:9:0","tags":["HTML"],"title":"【学习记录】HTML","uri":"/posts/log-html/"},{"categories":["实战记录"],"content":"实战网址：https://developer.mozilla.org/zh-CN/docs/Learn/Server-side/Express_Nodejs 源码：https://github.com/mdn/express-locallibrary-tutorial ","date":"2020-03-23","objectID":"/posts/mdn-local-library/:0:0","tags":["JavaScript","Node.js","Express","eslint","nodemon","pug","Mongoose"],"title":"【实战记录】MDN-Express Web Framework (Node.js/JavaScript)","uri":"/posts/mdn-local-library/"},{"categories":["实战记录"],"content":"搭建开发环境 ","date":"2020-03-23","objectID":"/posts/mdn-local-library/:1:0","tags":["JavaScript","Node.js","Express","eslint","nodemon","pug","Mongoose"],"title":"【实战记录】MDN-Express Web Framework (Node.js/JavaScript)","uri":"/posts/mdn-local-library/"},{"categories":["实战记录"],"content":"安装 Node 下载安装包 访问 https://nodejs.org/zh-cn/ 点击“推荐多数用户使用”（LTS），下载。 安装（Node.js 与 npm 同时安装） 测试 Node.js 与 npm 是否安装成功 在命令行种输入： $ node -v 与： $ npm -v 看是否返回结果 ","date":"2020-03-23","objectID":"/posts/mdn-local-library/:1:1","tags":["JavaScript","Node.js","Express","eslint","nodemon","pug","Mongoose"],"title":"【实战记录】MDN-Express Web Framework (Node.js/JavaScript)","uri":"/posts/mdn-local-library/"},{"categories":["实战记录"],"content":"安装 Express 应用生成器 Express 应用生成器工具可以生成一个 Express 应用的“框架”，用 npm 全局安装（-g 参数可以将该工具全局安装，这样就可以在任意应用中使用了） $ npm install express-generator -g 示例 创建一个名为“helloword”的 Express 应用 $ express helloword 安装应用的所有依赖 $ cd helloworld $ npm install 运行这个应用（Windows 环境）： \u003e SET DEBUG=helloworld:* \u0026 npm start (Linux/macOS 环境) $ DEBUG=helloworld:* npm start 这样设置之后，只要执行下面的命令，应用即启动，默认是 3000 端口 $ npm start ","date":"2020-03-23","objectID":"/posts/mdn-local-library/:1:2","tags":["JavaScript","Node.js","Express","eslint","nodemon","pug","Mongoose"],"title":"【实战记录】MDN-Express Web Framework (Node.js/JavaScript)","uri":"/posts/mdn-local-library/"},{"categories":["实战记录"],"content":"开发依赖 eslint(一款流行的 JavaScript lint 工具) 在当前项目的根目录下调用 npm $ npm install eslint --save-dev ","date":"2020-03-23","objectID":"/posts/mdn-local-library/:1:3","tags":["JavaScript","Node.js","Express","eslint","nodemon","pug","Mongoose"],"title":"【实战记录】MDN-Express Web Framework (Node.js/JavaScript)","uri":"/posts/mdn-local-library/"},{"categories":["实战记录"],"content":"创建站点框架 ","date":"2020-03-23","objectID":"/posts/mdn-local-library/:2:0","tags":["JavaScript","Node.js","Express","eslint","nodemon","pug","Mongoose"],"title":"【实战记录】MDN-Express Web Framework (Node.js/JavaScript)","uri":"/posts/mdn-local-library/"},{"categories":["实战记录"],"content":"Pug——选择视图引擎 Express 应用生成器支持多款流行的视图/模板引擎，包括 EJS、Hbs、Pug (Jade)、Twig 和 Vash，缺省选项是 Jade。Express 本身也支持大量其他模板语言，开箱即用。 本项目选用 Pug 模板引擎（Jade 是它不久前的曾用名），它是最流行的 Express / JavaScript 模板语言之一，且对 Express 生成器 开箱即用。 ","date":"2020-03-23","objectID":"/posts/mdn-local-library/:2:1","tags":["JavaScript","Node.js","Express","eslint","nodemon","pug","Mongoose"],"title":"【实战记录】MDN-Express Web Framework (Node.js/JavaScript)","uri":"/posts/mdn-local-library/"},{"categories":["实战记录"],"content":"创建项目 为本地图书馆应用创建一个名为 express-locallibrary-tutorial 的项目，使用 Pug 模板库，不使用 CSS 引擎。 进入要创建项目的文件根目录，执行下列命令 $ mkdir express-locallibrary-tutorial $ cd express-locallibrary-tutorial $ express --view=pug $ npm install $ DEBUG=express-locallibrary-tutorial:* npm start 一个 Express 应用就配置成功了，它托管于 localhost:3000 ","date":"2020-03-23","objectID":"/posts/mdn-local-library/:2:2","tags":["JavaScript","Node.js","Express","eslint","nodemon","pug","Mongoose"],"title":"【实战记录】MDN-Express Web Framework (Node.js/JavaScript)","uri":"/posts/mdn-local-library/"},{"categories":["实战记录"],"content":"nodemon——文件改动时重启服务器 nodemon 是最简便的服务器重启自动化工具。通常将其全局安装（因为它是一个“工具”） $ npm install nodemon -g 通过以下命令将其安装在骨架项目的根目录： $ npm install --save-dev nodemon 找的 package.json 的 scripts 部分。在\"start\"一行的末尾添加都好，并在新的一行中添加\"devstart\"，如下： \"scripts\":{ \"start\":\"node ./bin/www\", \"devstart\":\"nodemon ./bin/www\" } 新建 devstart 命令 $ DEBUG=express-locallibrary-tutorial:* npm run devstart 之后用 $ npm run devstart 即可启动应用，并且在文件更改后，服务器会重启 ","date":"2020-03-23","objectID":"/posts/mdn-local-library/:2:3","tags":["JavaScript","Node.js","Express","eslint","nodemon","pug","Mongoose"],"title":"【实战记录】MDN-Express Web Framework (Node.js/JavaScript)","uri":"/posts/mdn-local-library/"},{"categories":["实战记录"],"content":"使用数据库（Mongoose） ","date":"2020-03-23","objectID":"/posts/mdn-local-library/:3:0","tags":["JavaScript","Node.js","Express","eslint","nodemon","pug","Mongoose"],"title":"【实战记录】MDN-Express Web Framework (Node.js/JavaScript)","uri":"/posts/mdn-local-library/"},{"categories":["学习记录"],"content":"本文参考： https://developer.mozilla.org/zh-CN/docs/Learn/Common_questions/set_up_a_local_testing_server 安装 Python(windows 下) 转到 python.org 在“下载”部分下，单击 Python“3.xxx”的链接。 在页面的底部，选择 Windows x86 可执行文件安装程序并下载它。 当它已经下载，运行它。 在第一个安装程序页面上，确保选中了“将 Python 3.xxx 添加到 PATH”复选框。 单击安装，然后在安装完成后单击关闭。 打开命令提示符，检查 Python 是否安装，输入以下命令：（“V”是大写） python -V 使用 cd 命令导航到示例所在的目录。 输入命令在该目录中启动服务器： #如果上面返回的Python版本是3.X python -m http.server #如果上面返回的Python版本是2.X python -m SimpleHTTPServer 默认情况下这将在本地 Web 服务器上的端口 8000 上运行目录的内容，可以通过转到 localhost:8000Web 浏览器中的 URL 来访问此服务器。在这里可以看到列出的目录的内容，点击想运行的 HTML 文件。 注意：如果您已经在端口 8000 上运行了某些东西，则可以通过运行 server 命令，然后选择另一个端口号（例如 python -m http.server 7800 （Python 3.x）或 python -m SimpleHTTPServer 7800 （Python 2.x））来选择另一个端口。然后可以访问 localhost:7800。 如果要了解如何在本地运行服务器端语言，可以参考 https://developer.mozilla.org/zh-CN/docs/Learn/Common_questions/set_up_a_local_testing_server 的最后部分。 这篇博客几乎是从上面照搬下下来的，以防侵权，我在文章开头已经标明出处，写在这里的目的是怕我自己会忘记还有一个这样的方法，再加上，写在这里也更方便我之后查找。 ","date":"2020-03-14","objectID":"/posts/try-python-cross/:0:0","tags":["python","ajax","浏览器跨域","本地服务器"],"title":"【学习记录】利用python解决chrome异步加载本地文件报错","uri":"/posts/try-python-cross/"},{"categories":["学习记录"],"content":"在学习 ajax 的过程中，学习了一个例子，其中代码如下： function updateDisplay(verse) { verse = verse.replace(\" \", \"\"); verse = verse.toLowerCase(); let url = verse + \".txt\"; let request = new XMLHttpRequest(); request.open(\"GET\", url); request.responseType = \"text\"; request.onload = function () { poemDisplay.textContent = request.response; }; request.send(); } 但是按照以往直接打开的做法，浏览器控制台出现如下错误 from origin 'null' has been blocked by CORS policy: Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, https. 因为是从本地文件运行示例的，一些浏览器（包括 Chrome）不会运行异步请求，这是因为安全限制。（了解详情可参考：https://developer.mozilla.org/zh-CN/docs/learn/Server-side/First_steps/Website_security） 为了解决这个问题，经过多方搜索，我参考了 https://blog.csdn.net/saber872138/article/details/82995238 答案中的解决方法一，即利用 tomcat 解决。 按照 https://how2j.cn/k/tomcat/tomcat-tutorial/541.html 的介绍 首先安装 java 环境，在官网 https://www.oracle.com/java/technologies/javase-downloads.html 中选择要安装的版本，我选择的 JDK 是 Java SE 8u241，这时 Java SE 11 (LTS)是最新最稳定的版本，我先安装了这个版本，安装完之后，找不到 jre 文件，对于我这个搞不懂 jre 和 jdk 到底是啥的菜鸟来说，这两个在我印象中是缺一不可的，因为后面还有一项配置环境变量需要 jre 的所在目录，于是我把 Java SE 11 (LTS)卸载了，重新安装了 Java SE 8u241，也是我之前一直在用着的版本。这个安装文件包括了 jre 的安装，安装成功后就是设置环境变量，如下 变量名 变量值 JAVA_HOME D:\\Program Files (x86)\\Java\\jdk1.8.0_241 CLASSPATH .;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar; Path %JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin; 设置并保存，在命令行输入“java -version”，得出结果表示 java 环境已搭建好，接下来就要搞定 tomcat 了。 tomcat 是在官网 https://tomcat.apache.org/ 下载的压缩包，我下载的版本号是 9.0.31，直接将压缩包解压到特定文件下就行，然后打开根目录下的 bin 文件夹，找到 start.bat 并执行，刚开始启动 tomcat 的窗口出现乱码， 14-Mar-2020 20:23:03.593 淇℃伅 [main] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory [D:\\Program Files\\apache-tomcat-9.0.31\\webapps\\host-manager] has finished in [65] ms 14-Mar-2020 20:23:03.594 淇℃伅 [main] org.apache.catalina.startup.HostConfig.deployDirectory 鎶妛eb 搴旂敤绋嬪簭閮ㄧ讲 鍒扮洰褰?[D:\\Program Files\\apache-tomcat-9.0.31\\webapps\\manager] 14-Mar-2020 20:23:03.644 淇℃伅 [main] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory [D:\\Program Files\\apache-tomcat-9.0.31\\webapps\\manager] has finished in [51] ms 14-Mar-2020 20:23:03.645 淇℃伅 [main] org.apache.catalina.startup.HostConfig.deployDirectory 鎶妛eb 搴旂敤绋嬪簭閮ㄧ讲 鍒扮洰褰?[D:\\Program Files\\apache-tomcat-9.0.31\\webapps\\ROOT] 14-Mar-2020 20:23:03.690 淇℃伅 [main] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory [D:\\Program Files\\apache-tomcat-9.0.31\\webapps\\ROOT] has finished in [44] ms 14-Mar-2020 20:23:03.696 淇℃伅 [main] org.apache.coyote.AbstractProtocol.start 寮€濮嬪崗璁鐞嗗彞鏌刐\"http-nio-8080\"] 14-Mar-2020 20:23:03.717 淇℃伅 [main] org.apache.catalina.startup.Catalina.start Server startup in [1,273] milliseconds 我查了一下并且在这个 https://blog.csdn.net/weixin_39513118/article/details/86352063 回答下找到了答案，即修改 tomcat 的 conf 下的 logging.properties 中的参数，将 UTF-8 改为 GBK 即可。 java.util.logging.ConsoleHandler.encoding = GBK 将跨域出现问题的代码放在 tomcat 下的 webapps/ROOT 下，例如我放在 D:\\Program Files\\apache-tomcat-9.0.31\\webapps\\ROOT\\page\\api ，然后启动 tomcat，在浏览器上输入 http://localhost:8080/page/api/ajax-start.html 就能访问到该页面。 如果想更加全面了解 tomcat，接下来要花一段时间看看 https://how2j.cn/k/tomcat/tomcat-tutorial/541.html 根据 MDN 的这篇文章 https://developer.mozilla.org/zh-CN/docs/Learn/Common_questions/set_up_a_local_testing_server 可以知道，原来用 python 也可以，我决定试一试。 ","date":"2020-03-14","objectID":"/posts/try-tomcat/:0:0","tags":["tomcat","java","ajax","浏览器跨域","本地服务器"],"title":"【学习记录】利用tomcat解决chrome异步加载本地文件报错","uri":"/posts/try-tomcat/"},{"categories":["课程记录"],"content":"讲师：Amy 课程：https://www.imooc.com/learn/138 ","date":"2020-03-12","objectID":"/posts/imooc-dom/:0:0","tags":["dom","JavaScript","前端"],"title":"【慕课网】DOM事件探秘","uri":"/posts/imooc-dom/"},{"categories":["课程记录"],"content":"第一章 事件流 ","date":"2020-03-12","objectID":"/posts/imooc-dom/:1:0","tags":["dom","JavaScript","前端"],"title":"【慕课网】DOM事件探秘","uri":"/posts/imooc-dom/"},{"categories":["课程记录"],"content":"1-1 [DOM] 事件冒泡 事件流：描述的是从页面中接受事件的顺序 IE-事件冒泡流：即事件最开始由最具体的元素（文档中嵌套层次最深的那个节点）接受，然后逐级向上传播至最不具体的节点（文档）。 ","date":"2020-03-12","objectID":"/posts/imooc-dom/:1:1","tags":["dom","JavaScript","前端"],"title":"【慕课网】DOM事件探秘","uri":"/posts/imooc-dom/"},{"categories":["课程记录"],"content":"1-2 [DOM] 事件捕获 Netscape-事件捕获流：不太具体的节点应该更早接收到事件，而最具体的节点最后接收到事件。 ","date":"2020-03-12","objectID":"/posts/imooc-dom/:1:2","tags":["dom","JavaScript","前端"],"title":"【慕课网】DOM事件探秘","uri":"/posts/imooc-dom/"},{"categories":["课程记录"],"content":"第二章 事件处理程序 ","date":"2020-03-12","objectID":"/posts/imooc-dom/:2:0","tags":["dom","JavaScript","前端"],"title":"【慕课网】DOM事件探秘","uri":"/posts/imooc-dom/"},{"categories":["课程记录"],"content":"2-1 HTML 事件处理程序 例如： \u003cinput type=\"button\" value=\"按钮\" id=\"btn\" onclick=\"showMes()\" /\u003e 缺点：HTML 和 JS 代码紧密的耦合在一起;更新函数名时，JS 代码和 HTML 都要进行修改 ","date":"2020-03-12","objectID":"/posts/imooc-dom/:2:1","tags":["dom","JavaScript","前端"],"title":"【慕课网】DOM事件探秘","uri":"/posts/imooc-dom/"},{"categories":["课程记录"],"content":"2-2 DOM0 级事件处理程序 较传统的方式：把一个函数赋值给一个事件的处理程序属性，用的比较多的方法，简单、跨浏览器的优势 例如： var btn = document.getElementById('btn'); btn.onclick = function(){ alert('这是通过DOM0级添加的事件'); } btn.onclick = null;//删除事件 没有 HTML 事件处理程序的缺点 ","date":"2020-03-12","objectID":"/posts/imooc-dom/:2:2","tags":["dom","JavaScript","前端"],"title":"【慕课网】DOM事件探秘","uri":"/posts/imooc-dom/"},{"categories":["课程记录"],"content":"2-3 DOM2 级事件处理程序 没有 DOM1 级 DOM2 级定义了两个方法： 用于处理指定和删除事件处理程序的操作 addEventListener()和 removeEventListener()。 所有 DOM 节点包含这两个方法 接收三个参数：要处理的事件名、作为事件处理程序的函数和布尔值 例如： var btn = document.getElementById('btn'); btn.addEventListener('click',showMes,false);//false可以兼容浏览器，冒泡阶段 btn.addEventListener('click',function(){ alert(this.value); },false);//按钮被点击后，先执行上面的事件，再进行这个事件 btn.removeEventlistener('click',showMes,false);//删除事件，参数必须与添加事件时传的参数相同,且通过addEventListener添加的事件，只能通过removeEventListner删除。 DOM0 级和 DOM2 级可以给一个元素添加多个事件处理程序，按照它们的顺序进行执行。 ","date":"2020-03-12","objectID":"/posts/imooc-dom/:2:3","tags":["dom","JavaScript","前端"],"title":"【慕课网】DOM事件探秘","uri":"/posts/imooc-dom/"},{"categories":["课程记录"],"content":"2-4 IE 事件处理程序及跨浏览器解决 attachEvent()添加事件 detachEvent()删除事件 接收相同的两个参数：事件处理程序的名称和事件处理程序的函数 不适用第三个参数的原因：IE8 以及更早的浏览器版本支支持事件冒泡 例如： var btn = document.getElementById('btn'); btn.attachEvent('onclick',showMes);//添加事件 btn.detachEvent('onclick',showMes);//删除事件 支持 IE 事件处理程序的浏览器：IE 和 OPERA 跨浏览器解决，用能力检测 例如： var eventUtil = { //添加句柄 addHandler:function(element,type,handler){ if(element.addEventListener){//DOM2级别 element.addEventListener(type,handler,false); }else if(element.attachEvent){//IE element.attachEvent('on'+type,handler); }else{//不支持DOM0级和DOM2级 element['on'+type] = handler;//element.onclick===element['onclick'] } }, //删除句柄 removeHandler:function(element,type,handler){ if(element.addEventListener){//DOM2级别 element.removeEventListener(type,handler,false); }else if(element.attachEvent){//IE element.detachEvent('on'+type,handler); }else{//不支持DOM0级和DOM2级 element['on'+type] = null;//element.onclick===element['onclick'] } } } var btn = document.getElementById('btn'); eventUtil.addHandler(btn,'click',showMes); eventUtil.removeHandler(btn,'click',showMes); ","date":"2020-03-12","objectID":"/posts/imooc-dom/:2:4","tags":["dom","JavaScript","前端"],"title":"【慕课网】DOM事件探秘","uri":"/posts/imooc-dom/"},{"categories":["课程记录"],"content":"第三章 事件对象 什么是事件对象？在触发 DOM 上的事件时都会产生一个对象 事件对象 event ","date":"2020-03-12","objectID":"/posts/imooc-dom/:3:0","tags":["dom","JavaScript","前端"],"title":"【慕课网】DOM事件探秘","uri":"/posts/imooc-dom/"},{"categories":["课程记录"],"content":"3-1 DOM 中的事件对象 重要的属性 type 属性，用于获取事件类型 target 属性，用于获取事件目标(target.nodeName，节点名称) 重要的方法 stopPropagation()方法，用于阻止事件冒泡 preventDefault()方法，阻止事件的默认行为 \u003ca href=\"#\"\u003e超链接\u003c/a\u003e//此处，跳转是默认行为 ","date":"2020-03-12","objectID":"/posts/imooc-dom/:3:1","tags":["dom","JavaScript","前端"],"title":"【慕课网】DOM事件探秘","uri":"/posts/imooc-dom/"},{"categories":["课程记录"],"content":"3-2 IE 中的事件对象 type 属性，用于获取事件类型 srcElement 属性，用于获取事件目标 window.event 是用于兼容 ie 早期版本的，加上会更严谨 //在showMes(event)函数中 event = event||window.event; let ele = event.target||event.srcElement; cancelBubble 属性，用于阻止事件冒泡，设置为 true 表示阻止冒泡，设置为 false 表示不阻止冒泡 returnValue 属性，用于阻止事件的默认行为，设置为 false 表示阻止事件的默认行为 ","date":"2020-03-12","objectID":"/posts/imooc-dom/:3:2","tags":["dom","JavaScript","前端"],"title":"【慕课网】DOM事件探秘","uri":"/posts/imooc-dom/"},{"categories":["课程记录"],"content":"第四章 事件类型 ","date":"2020-03-12","objectID":"/posts/imooc-dom/:4:0","tags":["dom","JavaScript","前端"],"title":"【慕课网】DOM事件探秘","uri":"/posts/imooc-dom/"},{"categories":["课程记录"],"content":"4-1 [DOM 事件]QQ 面板拖拽效果（上） IE10 以前的浏览器不支持 document.getElementsByClassName() 鼠标事件都是在浏览器窗口中的特定位置上发生的。 这个位置信息保存在事件的 clientX 和 clientY 属性中。 所有浏览器都支持这两个属性，它们的值表示事件发生时鼠标指针在视口中的水平和垂直坐标。 不包括页面滚动的距离。 mousemove：当鼠标指针在元素内部移动时重复地触发 ","date":"2020-03-12","objectID":"/posts/imooc-dom/:4:1","tags":["dom","JavaScript","前端"],"title":"【慕课网】DOM事件探秘","uri":"/posts/imooc-dom/"},{"categories":["课程记录"],"content":"4-2 [DOM 事件]QQ 面板拖拽效果（下） 鼠标事件 onmouseover onmouseup onmousedown onmouseout onclick ","date":"2020-03-12","objectID":"/posts/imooc-dom/:4:2","tags":["dom","JavaScript","前端"],"title":"【慕课网】DOM事件探秘","uri":"/posts/imooc-dom/"},{"categories":["课程记录"],"content":"4-3 [DOM 事件]QQ 面板状态切换效果 在适当的地方阻止事件冒泡 ","date":"2020-03-12","objectID":"/posts/imooc-dom/:4:3","tags":["dom","JavaScript","前端"],"title":"【慕课网】DOM事件探秘","uri":"/posts/imooc-dom/"},{"categories":["课程记录"],"content":"4-4 [DOM 事件]抽奖系统（上） 键盘事件 keyDown 当用户按下键盘上的任意键时触发，而且如果按住不放的话，会重复触发此事件 keyPress 当用户按下键盘上的字符键时触发，而且如果按住不妨的话，会重复触发此事件 keyUp 当用户释放键盘上的键时触发 ","date":"2020-03-12","objectID":"/posts/imooc-dom/:4:4","tags":["dom","JavaScript","前端"],"title":"【慕课网】DOM事件探秘","uri":"/posts/imooc-dom/"},{"categories":["课程记录"],"content":"4-5 [DOM 事件]抽奖系统（下） EVENT 对象的 keyCoden 属性用于得到键盘对应键的键码值 ","date":"2020-03-12","objectID":"/posts/imooc-dom/:4:5","tags":["dom","JavaScript","前端"],"title":"【慕课网】DOM事件探秘","uri":"/posts/imooc-dom/"},{"categories":["bug解决记录"],"content":"在学习过程中遇到的一个例子，无法运行，例子的代码如下 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en-US\"\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003eMy test page\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cp\u003eThis is my page\u003c/p\u003e \u003cscript\u003e /*let promise = fetch('coffee.jpg'); let promise2 = promise.then(response=\u003eresponse.blob()); let promise3 = promise2.then(myBlob=\u003e{ let objectURL = URL.createObjectURL(myBlob); let image = document.createElement('img'); image.src = objectURL; document.body.appendChild(image); });*/ fetch('coffee.jpg') .then(response =\u003e response.blob()) .then(myBlob =\u003e { let objectURL = URL.createObjectURL(myBlob); let image = document.createElement('img'); image.src = objectURL; document.body.appendChild(image); }) .catch(e =\u003e { console.log(e.message); }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 遇到的问题如下 ","date":"2020-03-10","objectID":"/posts/myerror/:0:0","tags":["JavaScript","promise"],"title":"【错误记录】Failed to fetch","uri":"/posts/myerror/"},{"categories":null,"content":"function add(x, y) { return x + y; } @mentions, #refs, links, formatting, and tagssupported list syntax required (any unordered or ordered list supported) this is a complete item this is an incomplete item First Header Second Header Content from cell 1 Content from cell 2 Content in the first column Content in the second column a b 2 1 ^ 4 Andrew-\u003eChina: Says Hello Note right of China: China thinks\\nabout it China--\u003eAndrew: How are you? Andrew-\u003e\u003eChina: I am good thanks! st=\u003estart: 开始 op=\u003eoperation: My Operation cond=\u003econdition: Yes or No? e=\u003eend st-\u003eop-\u003econd cond(yes)-\u003ee cond(no)-\u003eop ","date":"2020-03-04","objectID":"/posts/test/:0:0","tags":["test"],"title":"测试markdown","uri":"/posts/test/"},{"categories":["课程记录"],"content":"讲师：翟路佳 课程：https://www.imooc.com/learn/949 代码：https://github.com/merrier/imooc-promise-sample ","date":"2020-03-02","objectID":"/posts/imooc-promise/:0:0","tags":["promise","JavaScript","前端"],"title":"【慕课网】Promise 入门教程","uri":"/posts/imooc-promise/"},{"categories":["课程记录"],"content":"第一章 异步的问题 ","date":"2020-03-02","objectID":"/posts/imooc-promise/:1:0","tags":["promise","JavaScript","前端"],"title":"【慕课网】Promise 入门教程","uri":"/posts/imooc-promise/"},{"categories":["课程记录"],"content":"1-1 课程介绍 了解 Promise 诞生的历史背景 学会使用 Promise 解决异步回调带来的问题 掌握 Promise 的进阶用法 ","date":"2020-03-02","objectID":"/posts/imooc-promise/:1:1","tags":["promise","JavaScript","前端"],"title":"【慕课网】Promise 入门教程","uri":"/posts/imooc-promise/"},{"categories":["课程记录"],"content":"1-2 Promise 释义 按照用途来解释 主要用于异步计算 可以将异步操作队列化，按照期望的顺序执行，返回复合预期的结果。 可以在对象之间传递和操作 Promise，帮助我们处理队列。 ","date":"2020-03-02","objectID":"/posts/imooc-promise/:1:2","tags":["promise","JavaScript","前端"],"title":"【慕课网】Promise 入门教程","uri":"/posts/imooc-promise/"},{"categories":["课程记录"],"content":"1-3 异步产生的原因 JavaScript 包含大量异步操作 有了 Node.js 之后，对异步的依赖进一步加剧了（无阻塞高并发，是 Node.js 的招牌；异步操作是其保障；大量操作依赖回调函数） 异步操作的常见语法 事件侦听与相应 回调 ","date":"2020-03-02","objectID":"/posts/imooc-promise/:1:3","tags":["promise","JavaScript","前端"],"title":"【慕课网】Promise 入门教程","uri":"/posts/imooc-promise/"},{"categories":["课程记录"],"content":"1-4 异步回调的问题 不好维护 异步回调函数会在一个新的栈运行，所以无法获取之前的栈的信息；之前的栈也无法捕获这个栈抛出的错误信息。所以没法正常使用 try catch 总结如下 嵌套层次很深，难以维护 无法正常使用 return 和 throw 无法正常检索堆栈信息 多个回调之间难以建立联系 ","date":"2020-03-02","objectID":"/posts/imooc-promise/:1:4","tags":["promise","JavaScript","前端"],"title":"【慕课网】Promise 入门教程","uri":"/posts/imooc-promise/"},{"categories":["课程记录"],"content":"第二章 Promise 入门 ","date":"2020-03-02","objectID":"/posts/imooc-promise/:2:0","tags":["promise","JavaScript","前端"],"title":"【慕课网】Promise 入门教程","uri":"/posts/imooc-promise/"},{"categories":["课程记录"],"content":"2-1 Promise 简介 使用之前，初始化 Promise 实例 new Promise( /* 执行器executor */ function (resolve, reject) { //一段耗时很长的异步操作 resolve(); //数据处理完成 reject(); //数据处理出错 } ).then( function A() { //调用resolve()成功，下一步 }, function B() { //调用reject()或抛出错误,做相应处理 } ); Promise 详解 Promise 是一个代理对象，它和原先要执行的操作并无关系。 它通过引入一个回调，避免更多的回调。 Promise 有三个状态： pending[待定]初始状态 fulfilled[实现]操作成功 rejected[被否决]操作失败 Promise 状态发生改变，就会触发.then()里的响应函数处理后续步骤。 Promise 状态一经改变，不会再变。 Promise 实例一经创建，执行器立即执行。 ","date":"2020-03-02","objectID":"/posts/imooc-promise/:2:1","tags":["promise","JavaScript","前端"],"title":"【慕课网】Promise 入门教程","uri":"/posts/imooc-promise/"},{"categories":["课程记录"],"content":"2-2 最简单的实例 timeout.js ","date":"2020-03-02","objectID":"/posts/imooc-promise/:2:2","tags":["promise","JavaScript","前端"],"title":"【慕课网】Promise 入门教程","uri":"/posts/imooc-promise/"},{"categories":["课程记录"],"content":"2-3 两步执行的范例 timeout2.js ","date":"2020-03-02","objectID":"/posts/imooc-promise/:2:3","tags":["promise","JavaScript","前端"],"title":"【慕课网】Promise 入门教程","uri":"/posts/imooc-promise/"},{"categories":["课程记录"],"content":"2-4 对已完成的 Promise 执行 then fulfilled-then.js 在任何地方生成一个 Promise 队列后，可以把它作为一个变量传递到其他地方，不管前面 Promise 队列是否完成，队列都会按照追加的 then 来执行。 ","date":"2020-03-02","objectID":"/posts/imooc-promise/:2:4","tags":["promise","JavaScript","前端"],"title":"【慕课网】Promise 入门教程","uri":"/posts/imooc-promise/"},{"categories":["课程记录"],"content":"2-5 then 里不返回 Promise timeout3.js 在 Promise 里，如果不直接返回一个 Promise 实例，那么它就会默认执行下一个环节，即使返回了 false，也不影响下一步，因为 false 会直接传递到下一环节里；如果没有明确返回值，相当于返回 undefined ","date":"2020-03-02","objectID":"/posts/imooc-promise/:2:5","tags":["promise","JavaScript","前端"],"title":"【慕课网】Promise 入门教程","uri":"/posts/imooc-promise/"},{"categories":["课程记录"],"content":"2-6 引出.then() .then()接受两个函数作为参数，分别代表 fulfilled 状态下的响应函数和 rejected 状态下的响应函数。 .then()返回一个新的 Promise 实例，所以它可以链式调用。 当前面的 Promise 状态改变时，.then()根据其最终状态，选择特定的状态响应函数执行。 状态响应函数可以返回新的 Promise，或其它值 如果返回新的 Promise，那么下一级.then()会在新 Promise 状态改变之后执行。 如果返回其它任何值，则会立刻执行下一级.then()。 ","date":"2020-03-02","objectID":"/posts/imooc-promise/:2:6","tags":["promise","JavaScript","前端"],"title":"【慕课网】Promise 入门教程","uri":"/posts/imooc-promise/"},{"categories":["课程记录"],"content":"第三章 小测试 ","date":"2020-03-02","objectID":"/posts/imooc-promise/:3:0","tags":["promise","JavaScript","前端"],"title":"【慕课网】Promise 入门教程","uri":"/posts/imooc-promise/"},{"categories":["课程记录"],"content":"3-1 then 的嵌套 nested-then.js .then()里有.then()的情况 因为.then()返回的还是 Promise 实例 会等里面的.then()执行完，再执行外面的 最好将其展开，会更好读 ","date":"2020-03-02","objectID":"/posts/imooc-promise/:3:1","tags":["promise","JavaScript","前端"],"title":"【慕课网】Promise 入门教程","uri":"/posts/imooc-promise/"},{"categories":["课程记录"],"content":"3-2 随堂小测试 问题：下面的四种 Promise 的区别是什么 //# 1 doSomething() .then(function () { return doSomethingElse(); }) .then(finalHandler); 执行顺序： doSomething doSomethingElse(undefined) – finalHandler(resultOfDoSomthingElse) – //#2 doSomething() .then(function () { doSomethingElse(); }) .then(finalHandler); 执行顺序： doSomething doSomethingElse(undefined) – finalHandler(resultOfDoSomthingElse) – //#3 doSomething().then(doSomethingElse()).then(finalHandler); 执行顺序： doSomething doSomethingElse(undefined) – finalHandle(resultOfDoSomething) – //#4 doSomething().then(doSomethingElse).then(finalHandler); 执行顺序： doSomething doSomethingElse(resultOfDoSomething) – finalHandler(resultOfDoSomethingElse) – ","date":"2020-03-02","objectID":"/posts/imooc-promise/:3:2","tags":["promise","JavaScript","前端"],"title":"【慕课网】Promise 入门教程","uri":"/posts/imooc-promise/"},{"categories":["课程记录"],"content":"3-3 错误处理 error.js error-reject.js Promise 会自动捕获内部异常，并交给 rejected 响应函数处理。 错误处理的两种做法 reject(‘错误信息’).then(null,message=\u003e{}) throw new Error(‘错误信息’).catch(message=\u003e{}) 推荐使用第二种，更加清晰好读，并且可以捕获前面的错误。 ","date":"2020-03-02","objectID":"/posts/imooc-promise/:3:3","tags":["promise","JavaScript","前端"],"title":"【慕课网】Promise 入门教程","uri":"/posts/imooc-promise/"},{"categories":["课程记录"],"content":"3-4 错误和 then 连用 catch-then.js catch 也会返回一个 Promise 实例，并且其中没有抛出错误的话，它返回的 Promise 实例是 fulfilled 状态的 注意 强烈建议在所有队列最后都加上.catch()，以避免漏掉错误处理造成意想不到的问题。 ","date":"2020-03-02","objectID":"/posts/imooc-promise/:3:4","tags":["promise","JavaScript","前端"],"title":"【慕课网】Promise 入门教程","uri":"/posts/imooc-promise/"},{"categories":["课程记录"],"content":"第四章 Promise 进阶 ","date":"2020-03-02","objectID":"/posts/imooc-promise/:4:0","tags":["promise","JavaScript","前端"],"title":"【慕课网】Promise 入门教程","uri":"/posts/imooc-promise/"},{"categories":["课程记录"],"content":"4-1 Promise.all 批量执行 Promise.all([p1,p2,p3,……])用于将多个 Promise 实例，包装成一个新的 Promise 实例 返回的实例是一个新的普通的 Promise 它接受一个数组作为参数 数组里可以是 Promise 对象，也可以是别的值，只有 Promise 会等待状态改变 当所有子 Promise 都完成，该 Promise 完成，返回值是全部值的数组 任何一个失败，该 Promise 失败，返回值是第一个失败的子 Promise 的结果 详见 all.js ","date":"2020-03-02","objectID":"/posts/imooc-promise/:4:1","tags":["promise","JavaScript","前端"],"title":"【慕课网】Promise 入门教程","uri":"/posts/imooc-promise/"},{"categories":["课程记录"],"content":"4-2 与.map 连用 Promise.all()最常见就是和.map()连用 map.js ","date":"2020-03-02","objectID":"/posts/imooc-promise/:4:2","tags":["promise","JavaScript","前端"],"title":"【慕课网】Promise 入门教程","uri":"/posts/imooc-promise/"},{"categories":["课程记录"],"content":"4-3 实现队列 ","date":"2020-03-02","objectID":"/posts/imooc-promise/:4:3","tags":["promise","JavaScript","前端"],"title":"【慕课网】Promise 入门教程","uri":"/posts/imooc-promise/"},{"categories":["课程记录"],"content":"4-4 实现爬虫 ","date":"2020-03-02","objectID":"/posts/imooc-promise/:4:4","tags":["promise","JavaScript","前端"],"title":"【慕课网】Promise 入门教程","uri":"/posts/imooc-promise/"},{"categories":["课程记录"],"content":"4-5 Promise.resolve ","date":"2020-03-02","objectID":"/posts/imooc-promise/:4:5","tags":["promise","JavaScript","前端"],"title":"【慕课网】Promise 入门教程","uri":"/posts/imooc-promise/"},{"categories":["课程记录"],"content":"4-6 Promise.reject ","date":"2020-03-02","objectID":"/posts/imooc-promise/:4:6","tags":["promise","JavaScript","前端"],"title":"【慕课网】Promise 入门教程","uri":"/posts/imooc-promise/"},{"categories":["课程记录"],"content":"4-7 Promise.race ","date":"2020-03-02","objectID":"/posts/imooc-promise/:4:7","tags":["promise","JavaScript","前端"],"title":"【慕课网】Promise 入门教程","uri":"/posts/imooc-promise/"},{"categories":["课程记录"],"content":"4-8 把回调包装成 Promise ","date":"2020-03-02","objectID":"/posts/imooc-promise/:4:8","tags":["promise","JavaScript","前端"],"title":"【慕课网】Promise 入门教程","uri":"/posts/imooc-promise/"},{"categories":["课程记录"],"content":"4-9 把任意异步操作包装成 Promise ","date":"2020-03-02","objectID":"/posts/imooc-promise/:4:9","tags":["promise","JavaScript","前端"],"title":"【慕课网】Promise 入门教程","uri":"/posts/imooc-promise/"},{"categories":["学习记录"],"content":"将\u003cscript\u003e放在 HTML 文件的底部附近的原因 浏览器会按照代码在文件中的顺序加载 HTML，如果先加载的 JavaScript 期望修改其下方的 HTML，那么它可能由于 HTML 尚未被加载而失效。因此，将 JavaScript 代码放在 HTML 页面的底部附近通常是最好的策略。 ","date":"2020-02-17","objectID":"/posts/frontlog/:1:0","tags":["JavaScript"],"title":"【学习记录】JavaScript","uri":"/posts/frontlog/"},{"categories":["学习记录"],"content":"JavaScript 的命名规则 一个 JavaScript 标识符必须以字母、下划线（_）或者美元符号（$）开头；后续的字符也可以是数字（0-9）。因为 JavaScript 语言是区分大小写的，所以字母可以是从“A”到“Z”的大写字母和从“a”到“z”的小写字母。 ","date":"2020-02-17","objectID":"/posts/frontlog/:2:0","tags":["JavaScript"],"title":"【学习记录】JavaScript","uri":"/posts/frontlog/"},{"categories":["学习记录"],"content":"数据类型 JavaScript 是一种弱类型或者说动态语言。这意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。这也意味着可以使用同一个变量保存不同类型的数据： 7 种原始类型: Boolean Null Undefined Number BigInt String Symbol 和 Object ","date":"2020-02-17","objectID":"/posts/frontlog/:3:0","tags":["JavaScript"],"title":"【学习记录】JavaScript","uri":"/posts/frontlog/"},{"categories":["学习记录"],"content":"数学运算符 幂次 运算符 名称 作用 示例 ** 幂次 取底数的指数次方，即指数所指定的底数相乘。它在 EcmaScript 2016 中首次引入。 5 *_ 5 (返回 3125，相当于 5 _ 5 _ 5 _ 5 * 5 。) ","date":"2020-02-17","objectID":"/posts/frontlog/:4:0","tags":["JavaScript"],"title":"【学习记录】JavaScript","uri":"/posts/frontlog/"},{"categories":["学习记录"],"content":"数组的 join()函数 数组 join（）函数的参数是可选的，如果没有包含参数来指定加入/分隔符，默认情况下会使用逗号。例如， var myArray = [\"I\", \"love\", \"chocolate\", \"frogs\"]; var madeAString = myArray.join(\" \"); // returns 'I love chocolate frogs' var madeAString = myArray.join(); // returns 'I,love,chocolate,frogs' ","date":"2020-02-17","objectID":"/posts/frontlog/:5:0","tags":["JavaScript"],"title":"【学习记录】JavaScript","uri":"/posts/frontlog/"},{"categories":["学习记录"],"content":"函数调用运算符 在函数名后面的括号叫做“函数调用运算符”，只有在想直接调用函数的地方才写。例如， btn.onclick = displayMessage; //没有括号，函数不会调用，只会在点击之后调用 btn.onclick = displayMessage(); //有括号，代码运行到这行会直接调用函数,并且之后点击也不会调用该函数 ","date":"2020-02-17","objectID":"/posts/frontlog/:6:0","tags":["JavaScript"],"title":"【学习记录】JavaScript","uri":"/posts/frontlog/"},{"categories":["学习记录"],"content":"对象的括号表示法 点表示法只能接受字面量的成员的名字，不接受变量作为名字，但是括号表示法可以接受变量作为名字，如下： var myDataName = \"height\"; var myDataValue = \"1.75m\"; person[myDataName] = myDataValue; //person是一个对象 在控制台输入 person.height 会输出 1.75m 即把“height”当作了对象的成员名，“1.75m”当作了“height”的属性值。 ","date":"2020-02-17","objectID":"/posts/frontlog/:7:0","tags":["JavaScript"],"title":"【学习记录】JavaScript","uri":"/posts/frontlog/"},{"categories":["学习记录"],"content":"JavaScript 中的继承有关问题 每一个函数对象（Function）都有一个 prototype 属性，并且只有函数对象有 prototype 属性，因为 prototype 本身就是定义在 Function 对象下的属性。当我们输入类似 var person1=new Person(…)来构造对象时，JavaScript 实际上参考的是 Person.prototype 指向的对象来生成 person1。另一方面，Person()函数是 Person.prototype 的构造函数，也就是说 Person===Person.prototype.constructor（不信的话可以试试）。 在定义新的构造函数 Teacher 时，我们通过 function.call 来调用父类的构造函数，但是这样无法自动指定 Teacher.prototype 的值，这样 Teacher.prototype 就只能包含在构造函数里构造的属性，而没有方法。因此我们利用 Object.create()方法将 Person.prototype 作为 Teacher.prototype 的原型对象，并改变其构造器指向，使之与 Teacher 关联。 任何您想要被继承的方法都应该定义在构造函数的 prototype 对象里，并且永远使用父类的 prototype 来创造子类的 prototype，这样才不会打乱类继承结构。 ","date":"2020-02-17","objectID":"/posts/frontlog/:8:0","tags":["JavaScript"],"title":"【学习记录】JavaScript","uri":"/posts/frontlog/"},{"categories":["学习记录"],"content":"对象成员总结 那些定义在构造器函数中的、用于给予对象实例的。这些都很容易发现 - 在您自己的代码中，它们是构造函数中使用 this.x = x 类型的行；在内置的浏览器代码中，它们是可用于对象实例的成员（通常通过使用 new 关键字调用构造函数来创建，例如 var myInstance = new myConstructor()）。 那些直接在构造函数上定义、仅在构造函数上可用的。这些通常仅在内置的浏览器对象中可用，并通过被直接链接到构造函数而不是实例来识别。 例如 Object.keys()。 那些在构造函数原型上定义、由所有实例和对象类继承的。这些包括在构造函数的原型属性上定义的任何成员，如 myConstructor.prototype.x()。 ","date":"2020-02-17","objectID":"/posts/frontlog/:9:0","tags":["JavaScript"],"title":"【学习记录】JavaScript","uri":"/posts/frontlog/"},{"categories":["学习记录"],"content":"JSON 的两个方法 parse(): 以文本字符串形式接受 JSON 对象作为参数，并返回相应的对象。 stringify(): 接收一个对象作为参数，返回一个对应的 JSON 字符串。 ","date":"2020-02-17","objectID":"/posts/frontlog/:10:0","tags":["JavaScript"],"title":"【学习记录】JavaScript","uri":"/posts/frontlog/"},{"categories":["学习记录"],"content":"异步编程 老派 callbacks 新派 promise ","date":"2020-02-17","objectID":"/posts/frontlog/:11:0","tags":["JavaScript"],"title":"【学习记录】JavaScript","uri":"/posts/frontlog/"},{"categories":["学习记录"],"content":"递归 setTimeout()和 setInterval()的差异 - 递归 setTimeout() 保证执行之间的延迟相同，例如延迟为100ms。代码将运行，然后在它再次运行之前等待100ms，因此无论代码运行多长时间，间隔都是相同的。 - 使用 setInterval() 的示例有些不同。我们选择的间隔包括执行我们想要运行的代码所花费的时间。假设代码需要40毫秒才能运行 - 然后间隔最终只有60毫秒。 - 当递归使用 setTimeout() 时，每次迭代都可以在运行下一次迭代之前计算不同的延迟。 换句话说，第二个参数的值可以指定在再次运行代码之前等待的不同时间（以毫秒为单位）。 因此，当你的代码有可能比你分配的时间间隔，花费更长时间运行时，最好使用递归的 setTimeout() - 这将使执行之间的时间间隔保持不变，无论代码执行多长时间，你不会得到错误。 —–\u003e摘自 MDN https://developer.mozilla.org/zh-CN/docs/learn/JavaScript/%E5%BC%82%E6%AD%A5/%E8%B6%85%E6%97%B6%E5%92%8C%E9%97%B4%E9%9A%94 下同 ","date":"2020-02-17","objectID":"/posts/frontlog/:12:0","tags":["JavaScript"],"title":"【学习记录】JavaScript","uri":"/posts/frontlog/"},{"categories":["学习记录"],"content":"requestAnimationFrame() 与 setInterval() 和 setTimeout()的差异 这是 requestAnimationFrame() function draw() { // Drawing code goes here requestAnimationFrame(draw); } draw(); 这是 setInterval() function draw() { // Drawing code goes here } setInterval(draw, 17); 没有为 requestAnimationFrame();指定时间间隔；它只是在当前条件下尽可 另一方面 setInterval()需要指定间隔。我们通过公式 1000 毫秒/60Hz 得出 17 的最终值，然后将其四舍五入。四舍五入是一个好主意，浏览器可能会尝试运行动画的速度超过 60fps，它不会对动画的平滑度有任何影响。 60Hz 是标准刷新率。 ","date":"2020-02-17","objectID":"/posts/frontlog/:13:0","tags":["JavaScript"],"title":"【学习记录】JavaScript","uri":"/posts/frontlog/"},{"categories":["学习记录"],"content":"offsetParent，parentNode,parentElement 区别 offsetParent 指与位置有关的上级元素 parentNode 指与位置无关的上级元素 parentElement 和 parentNode 一样，但是 parentNode 是 W3C 标准的,parentElement 只在 IE 中可用。 ","date":"2020-02-17","objectID":"/posts/frontlog/:14:0","tags":["JavaScript"],"title":"【学习记录】JavaScript","uri":"/posts/frontlog/"},{"categories":["学习记录"],"content":"获取输入框 input 的值 用.value 而不是.textContent ","date":"2020-02-17","objectID":"/posts/frontlog/:15:0","tags":["JavaScript"],"title":"【学习记录】JavaScript","uri":"/posts/frontlog/"},{"categories":["学习记录"],"content":"从网络获取资源 从网络获取资源是一个 asynchronous “异步” 操作, 这意味着您必须等待该操作完成（例如，资源从网络返回），然后才能对该响应执行任何操作，否则会出错,将被抛出错误。 ","date":"2020-02-17","objectID":"/posts/frontlog/:16:0","tags":["JavaScript"],"title":"【学习记录】JavaScript","uri":"/posts/frontlog/"},{"categories":["学习记录"],"content":"canvas 不明确指明宽高时，画布默认尺寸为 300*150 像素 ","date":"2020-02-17","objectID":"/posts/frontlog/:17:0","tags":["JavaScript"],"title":"【学习记录】JavaScript","uri":"/posts/frontlog/"},{"categories":["学习记录"],"content":"ctx.drawImage() ctx.drawImage(image, 20, 20, 185, 175, 50, 50, 185, 175); 第一个参数为图片引用。 参数 2、3 指定切片左上顶点在原图的位置坐标，参考原点为原图片本身左上角的坐标。原图片在该坐标左、上的部分均不会绘制出来。 参数 4、5 表示裁切部分的长、宽。 参数 6、7 表示裁切部分左上顶点在画布中的位置坐标，参考原点为画布左上顶点。 参数 8、9 表示裁切部分在画布中绘制的长、宽。本例中绘制时与裁切时面积相同，你也可以定制绘制的尺寸。 ","date":"2020-02-17","objectID":"/posts/frontlog/:18:0","tags":["JavaScript"],"title":"【学习记录】JavaScript","uri":"/posts/frontlog/"},{"categories":["学习记录"],"content":"网络标准 RFC7230 HTTP 消息的格式是在“网络标准”（RFC7230）中定义的。 ","date":"2020-02-17","objectID":"/posts/frontlog/:19:0","tags":["JavaScript"],"title":"【学习记录】JavaScript","uri":"/posts/frontlog/"},{"categories":["杂记"],"content":" 博客文章的文件名不要用大写字母 编写博客文章时按住 ctrl+shift+v，可以预览 md 文件，这是 Markdown Preview Enhanced 插件的功劳，这里的预览与 vscode 自带的预览效果不同。 创建博客新文章：npx hexo new “\u003c文章所属文件名\u003e 根据已更改，生成更改信息：npx hexo g 部署网站，将更改提交：npx hexo d 在本地预览网站：npx hexo s 清除缓存：npx hexo clean 由于我的某个操作 使得前面不需要再加 hexo 啦~ ","date":"2020-02-17","objectID":"/posts/blog-log/:0:0","tags":["博客"],"title":"关于博客","uri":"/posts/blog-log/"}]